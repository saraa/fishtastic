<Type Name="Widget" FullName="Gtk.Widget">
  <TypeSignature Language="C#" Value="public class Widget : Gtk.Object, Implementor, IWrapper, IWrapper, IDisposable" Maintainer="Hector Gomez M" />
  <AssemblyInfo>
    <AssemblyName>gtk-sharp</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
    <Attributes />
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the <link location="node:gtk-sharp/programming/threads">Gtk# Thread Programming</link> for details.</ThreadSafetyStatement>
  <Docs>
    <summary>GtkWidget introduces style properties - these are basically object properties that are stored in the style object associated to the widget.</summary>
    <remarks>
      <para>
      Style properties are set in resource files. This mechanism is used for configuring such things as the location of the scrollbar arrows through the theme, giving theme authors more control over the look of applications without the need to write a theme engine in C.
     </para>
      <para>
      Use <see cref="M:Gtk.Widget.StyleGetProperty" />, <see cref="P:Gtk.Widget.Style" /> or <see cref="M:Gtk.Widget.StyleGetValist" /> to obtain the value of a style property.
     </para>
    </remarks>
  </Docs>
  <Base>
    <BaseTypeName>Gtk.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Atk.Implementor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>GLib.IWrapper</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>GLib.IWrapper</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes />
  <Members>
    <Member MemberName="PushCompositeChild">
      <MemberSignature Language="C#" Value="public static void PushCompositeChild ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Makes all newly-created <paramref name="widgets" /> as composite children until the corresponding <see cref="M:Gtk.Widget.PopCompositeChild" /> call.</summary>
        <remarks>
          <para>
          A composite child is a child that's an implementation detail of the container it's inside and should not be visible to people using the container. Composite children aren't treated differently by GTK (but see <see cref="M:Gtk.Container.Foreach" /> vs. <see cref="M:GtkContainer.Forall" />), but e.g. GUI builders might want to treat them in a different way.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushColormap">
      <MemberSignature Language="C#" Value="public static void PushColormap (Gdk.Colormap cmap);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cmap" Type="Gdk.Colormap" />
      </Parameters>
      <Docs>
        <summary>Pushes <paramref name="cmap" /> onto a global stack of colormaps.</summary>
        <param name="cmap">Colormap that is pushed by <see cref="T:Gdk.Colormap" />.</param>
        <remarks>
          <para>
          Pushes <paramref name="cmap" /> onto a global stack of colormaps; the topmost colormap on the stack will be used to create all widgets. Remove <paramref name="cmap" /> with <see cref="M:Gtk.Widget.PopColormap" />. There's little reason to use this function.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PopColormap">
      <MemberSignature Language="C#" Value="public static void PopColormap ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes a colormap pushed with <see cref="M:Gtk.Widget.PushColormap" />.</summary>
        <remarks>
          <para>
          Removes a colormap pushed with <see cref="M:Gtk.Widget.PushColormap" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PopCompositeChild">
      <MemberSignature Language="C#" Value="public static void PopCompositeChild ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the effect of a previous call to <see cref="M:Gtk.Widget.PushCompositeChild" />.</summary>
        <remarks>
          <para>
          Cancels the effect of a previous call to <see cref="M:Gtk.Widget.PushCompositeChild" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RefAccessible">
      <MemberSignature Language="C#" Value="public virtual Atk.Object RefAccessible ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Atk.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a reference to an object's <see cref="T:Atk.Object" /> implementation.</summary>
        <returns>An <see cref="T:Atk.Object" />.</returns>
        <remarks>
          <para>
          Gets a reference to an object's <see cref="T:Atk.Object" /> implementation.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowNow">
      <MemberSignature Language="C#" Value="public void ShowNow ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Shows a <paramref name="widget" />.</summary>
        <remarks>
          <para>
          If the <paramref name="widget" /> is an unmapped toplevel widget, a <see cref="T:Gtk.Window" /> that has not yet been shown, enter the main loop and wait for the window to actually be mapped. Be careful, because the main loop is running, anything can happen during this function.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GrabDefault">
      <MemberSignature Language="C#" Value="public void GrabDefault ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes <paramref name="widget" /> to become the default <paramref name="widget" />.</summary>
        <remarks>
          <para>
          The default <paramref name="widget" /> is activated when the user presses Enter in a window. Default widgets must be activatable, that is, <see cref="M:Gtk.Widget.Activate" /> should affect them. The <paramref name="widgets" /> must have the <see cref="F:Gtk.WidgetFlags.CanDefault" /> flag set; typically you have to set this flag yourself by calling <see cref="P:Gtk.Widget.CanDefault" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reparent">
      <MemberSignature Language="C#" Value="public void Reparent (Gtk.Widget new_parent);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="new_parent" Type="Gtk.Widget" />
      </Parameters>
      <Docs>
        <summary>Moves a <paramref name="widget" /> from one <see cref="T:Gtk.Container" /> to another, handling reference count issues to avoid destroying the widget.</summary>
        <param name="new_parent">A <see cref="T:Gtk.Container" /> to move the widget into.</param>
        <remarks>
          <para>
          Moves a widget from one <see cref="T:Gtk.Container" /> to another, handling reference count issues to avoid destroying the widget.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildFocus">
      <MemberSignature Language="C#" Value="public bool ChildFocus (Gtk.DirectionType direction);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="Gtk.DirectionType" />
      </Parameters>
      <Docs>
        <summary>Move focus to particular <paramref name="widget" />.</summary>
        <param name="direction">Direction of focus movement.</param>
        <returns>
          <see langword="true" /> if focus ended up inside widget.</returns>
        <remarks>
          <para>
          This function is used by custom widget implementations; if you're writing an app, you'd use <see cref="M:Gtk.Widget.GrabFocus" /> to move the focus to a particular widget, and <see cref="M:Gtk.Container.SetFocusChain" /> to change the focus tab order. So you may want to investigate those functions instead.
         </para>
          <para>
            <see cref="M:Gtk.Widget.ChildFocus" /> is called by containers as the user moves around the window using keyboard shortcuts. <paramref name="direction" /> indicates what kind of motion is taking place (up, down, left, right, tab forward, tab backward). <see cref="M:Gtk.Widget.ChildFocus" /> invokes the "focus" signal on <see cref="T:Gtk.Widget" />; widgets override the default handler for this signal in order to implement appropriate focus behavior.
         </para>
          <para>
          The "focus" default handler for a widget should return <see langword="true" /> if moving in direction left the focus on a focusable location inside that widget, and <see langword="false" /> if moving in direction moved the focus outside the widget. If returning <see langword="true" />, widgets normally call <see cref="M:Gtk.Widget.GrabFocus" /> to place the focus accordingly; if returning <see langword="false" />, they don't modify the current focus location.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unparent">
      <MemberSignature Language="C#" Value="public void Unparent ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Should be called by implementations of the remove method on <see cref="T:Gtk.Container" />, to dissociate a child from the container.</summary>
        <remarks>
          <para>
          This function is only for use in widget implementations.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Realize">
      <MemberSignature Language="C#" Value="public void Realize ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates the GDK (windowing system) resources associated with a <paramref name="widget" />.</summary>
        <remarks>
          <para>
          For example, <paramref name="widget" />-&gt;window will be created when a widget is realized. Normally realization happens implicitly; if you show a widget and all its parent containers, then the widget will be realized and mapped automatically. Realizing a widget requires all the widget's parent widgets to be realized; calling <see cref="M:Gtk.Widget.Realize" /> realizes the widget's parents in addition to widget itself. If a widget is not yet inside a toplevel window when you realize it, bad things will happen. 
         </para>
          <para>
          This function is primarily used in widget implementations, and isn't very useful otherwise. Many times when you think you might need it, a better approach is to connect to a signal that will be called after the widget is realized automatically, such as <see cref="F:Gtk.Widget.ExposeEvent" />. Or simply <see cref="M:Glib.SignalAttr.ConnectAfter" /> to the realize signal.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueDrawArea">
      <MemberSignature Language="C#" Value="public void QueueDrawArea (int x, int y, int width, int height);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Invalidates the rectangular area of a <paramref name="widget" />.</summary>
        <param name="x">y coordinate of upper-left corner of rectangle to redraw.</param>
        <param name="y">x coordinate of upper-left corner of rectangle to redraw.</param>
        <param name="width">Width of region to draw.</param>
        <param name="height">Height of region to draw.</param>
        <remarks>
          <para>
          Invalidates the rectangular area of widget defined by <paramref name="x" />, <paramref name="y" />, <paramref name="width" /> and <paramref name="height" /> by calling <see cref="M:Gdk.Window.InvalidateRect" /> on the widget's window and all its child windows. Once the main loop becomes idle (after the current batch of events has been processed, roughly), the window will receive <see cref="F:Gtk.Widget.ExposeEvent" /> events for the union of all regions that have been invalidated.
         </para>
          <para>
          Normally you would only use this function in widget implementations. You might also use it, or <see cref="M:Gdk.Window.InvalidateRect" /> directly, to schedule a redraw of a <see cref="T:Gtk.DrawingArea" /> or some portion thereof. Frequently you can just call <see cref="M:Gdk.Window.InvalidateRect" /> or <see cref="M:Gdk.Window.InvalidateRegion" /> instead of this function. Those functions will invalidate only a single window, instead of the widget and all its children.
         </para>
          <para>
          The advantage of adding to the invalidated region compared to simply drawing immediately is efficiency; using an invalid region ensures that you only have to redraw one time.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifyFg">
      <MemberSignature Language="C#" Value="public void ModifyFg (Gtk.StateType state, Gdk.Color color);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="Gtk.StateType" />
        <Parameter Name="color" Type="Gdk.Color" />
      </Parameters>
      <Docs>
        <summary>Sets the foreground <paramref name="color" /> for a <paramref name="widget" /> in a particular <paramref name="state" />.</summary>
        <param name="state">The state for which to set the background color.</param>
        <param name="color">The color to assign (does not need to be allocated), or <see langword="null" /> to undo the effect of previous calls to of <see cref="M:Gtk.Widget.ModifyFg" />.</param>
        <remarks>
          <para>
          All other style values are left untouched. See also <see cref="M:Gdk.Widget.ModifyStyle" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderIcon">
      <MemberSignature Language="C#" Value="public Gdk.Pixbuf RenderIcon (string stock_id, Gtk.IconSize size, string detail);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Pixbuf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stock_id" Type="System.String" />
        <Parameter Name="size" Type="Gtk.IconSize" />
        <Parameter Name="detail" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>A convenience function that uses the theme engine and RC file settings for <paramref name="widget" /> to look up <paramref name="stock_id" /> and render it to a <see cref="T:Gdk.Pixbuf" />.</summary>
        <param name="stock_id">A stock ID.</param>
        <param name="size">A stock size.</param>
        <param name="detail">Render detail to pass to theme engine.</param>
        <returns>A new <see cref="T:Gdk.Pixbuf" />, or <see langword="null" /> if the <paramref name="stock_id" /> wasn't known.</returns>
        <remarks>
          <para>
          The <paramref name="stock_id" /> should be a stock icon ID such as <see cref="P:Gtk.Stock.Open" /> or <see cref="P:Gtk.Stock.Ok" />. <paramref name="size" /> should be a size such as <see cref="F:Gtk.IconSize.Menu" />. <paramref name="detail" /> should be a string that identifies the widget or code doing the rendering, so that theme engines can special-case rendering for that widget or code.
         </para>
          <para>
          The pixels in the returned <see cref="T:Gdk.Pixbuf" /> are shared with the rest of the application and should not be modified. The <see cref="T:Gdk.Pixbuf" /> should be freed after use with <see cref="M:Glib.Object.Unref" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleGetValist">
      <MemberSignature Language="C#" Value="public void StyleGetValist (string first_property_name, IntPtr var_args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first_property_name" Type="System.String" />
        <Parameter Name="var_args" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <summary>Gets the values of a multiple style properties of <paramref name="widgets" />.</summary>
        <param name="first_property_name">The name of the first property to get.</param>
        <param name="var_args">A va_list of pairs of property names and locations to return the property values, starting with the location for <paramref name="first_property_name" />.</param>
        <remarks>
          <para>
          Gets the values of a multiple style properties of <paramref name="widget" />. Used primarily by language bindings.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowAll">
      <MemberSignature Language="C#" Value="public void ShowAll ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recursively shows a <paramref name="widget" />, and any child <paramref name="widgets" /> (if the widget is a container).</summary>
        <remarks>
          <para>
          Recursively shows a <paramref name="widget" />, and any child <paramref name="widgets" /> (if the widget is a container).
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifyText">
      <MemberSignature Language="C#" Value="public void ModifyText (Gtk.StateType state, Gdk.Color color);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="Gtk.StateType" />
        <Parameter Name="color" Type="Gdk.Color" />
      </Parameters>
      <Docs>
        <summary>Sets the text <paramref name="color" /> for a <paramref name="widget" /> in a particular state.</summary>
        <param name="state">The state for which to set the text color.</param>
        <param name="color">The color to assign (does not need to be allocated), or <see langword="null" /> to undo the effect of previous calls to of <see cref="M:Gtk.Widget.ModifyText" />.</param>
        <remarks>
          <para>
          All other style values are left untouched. The text color is the foreground color used along with the base color (see <see cref="M:Gtk.Widget.ModifyBase" />) for widgets such as <see cref="T:Gtk.Entry" /> and <see cref="T:Gtk.TextView" />. See also <see cref="M:Gtk.Widget.ModifyStyle" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreatePangoContext">
      <MemberSignature Language="C#" Value="public Pango.Context CreatePangoContext ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Pango.Context</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="P:Gtk.Widget.PangoContext" /> with the appropriate colormap, font description, and base direction for drawing text for <paramref name="widget" />.</summary>
        <returns>The new <see cref="P:Gtk.Widget.PangoContext" />.</returns>
        <remarks>
          <para>
          See also <see cref="P:Gtk.Widget.PangoContext" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HideOnDelete">
      <MemberSignature Language="C#" Value="public bool HideOnDelete ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Utility function; intended to be connected to the <see cref="F:Gtk.Widget.DeleteEvent" /> signal on a <see cref="T:Gtk.Window" />.</summary>
        <returns>Returns <see langword="true" />.</returns>
        <remarks>
          <para>
          The function calls <see cref="M:Gtk.Widget.Hide" /> on its argument, then returns <see langword="true" />. If connected to <see cref="F:Gtk.Widget.DeleteEvent" />, the result is that clicking the close button for a window (on the window frame, top right corner usually) will hide but not destroy the window. By default, GTK+ destroys windows when <see cref="F:Gtk.Widget.DeleteEvent" /> is received.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildRequisition">
      <MemberSignature Language="C#" Value="public void GetChildRequisition (Gtk.Requisition requisition);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requisition" Type="Gtk.Requisition" />
      </Parameters>
      <Docs>
        <summary>Obtains <paramref name="widget" />-&gt;<paramref name="requisition" />.</summary>
        <param name="requisition">A <see cref="T:Gtk.Requisition" /> to be filled in.</param>
        <remarks>
          <para>
          Obtains <paramref name="widget" />-&gt;<paramref name="requisition" />, unless someone has forced a particular geometry on the widget, in which case it returns that geometry instead of the widget's <paramref name="requisition" />. This function differs from <see cref="M:Gtk.Widget.SizeRequest" /> in that it retrieves the last size request value from <paramref name="widget" />-&gt;<paramref name="requisition" />, while the <see cref="M:Gtk.Widget.SizeRequest" /> method computes the size request and fill in <paramref name="widget" />-&gt;<paramref name="requisition" />, and only then returns <paramref name="widget" />-&gt;<paramref name="requisition" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GrabFocus">
      <MemberSignature Language="C#" Value="public void GrabFocus ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes a <paramref name="widget" /> to have the keyboard focus for the <see cref="T:Gtk.Window" /> it's inside.</summary>
        <remarks>
          <para>
          The <paramref name="widget" /> must be a focusable widget, such as a <see cref="T:Gtk.Entry" />; something like <see cref="T:Gtk.Frame" /> won't work (More precisely, it must have the <see cref="P:Gtk.Widget.CanFocus" /> flag set).
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueDraw">
      <MemberSignature Language="C#" Value="public void QueueDraw ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Equivalent to calling <see cref="M:Gtk.Widget.QueueDrawArea" /> for the entire area of a <paramref name="widget" />.</summary>
        <remarks>
          <para>
          Equivalent to calling <see cref="M:Gtk.Widget.QueueDrawArea" /> for the entire area of a <paramref name="widget" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccelPath">
      <MemberSignature Language="C#" Value="public void SetAccelPath (string accel_path, Gtk.AccelGroup accel_group);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accel_path" Type="System.String" />
        <Parameter Name="accel_group" Type="Gtk.AccelGroup" />
      </Parameters>
      <Docs>
        <summary>Given an accelerator group, <paramref name="accel_group" />, and an accelerator path, <paramref name="accel_path" />, sets up an accelerator in <paramref name="accel_group" /> so whenever the key binding that is defined for <paramref name="accel_path" /> is pressed, <paramref name="widget" /> will be activated.</summary>
        <param name="accel_path">Path used to look up the the accelerator.</param>
        <param name="accel_group">A <see cref="T:Gtk.AccelGroup" />.</param>
        <remarks>
          <para>
          This removes any accelerators (for any accelerator group) installed by previous calls to <see cref="M:Gtk.Widget.SetAccelPath" />. Associating accelerators with paths allows them to be modified by the user and the modifications to be saved for future use.
         </para>
          <para>
          This function is a low level function that would most likely be used by a menu creation system like <see cref="T:Gtk.ItemFactory" />. If you use <see cref="T:Gtk.ItemFactory" />, setting up accelerator paths will be done automatically.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccelerator">
      <MemberSignature Language="C#" Value="public void AddAccelerator (string accel_signal, Gtk.AccelGroup accel_group, uint accel_key, Gdk.ModifierType accel_mods, Gtk.AccelFlags accel_flags);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accel_signal" Type="System.String" />
        <Parameter Name="accel_group" Type="Gtk.AccelGroup" />
        <Parameter Name="accel_key" Type="System.UInt32" />
        <Parameter Name="accel_mods" Type="Gdk.ModifierType" />
        <Parameter Name="accel_flags" Type="Gtk.AccelFlags" />
      </Parameters>
      <Docs>
        <summary>Installs an accelerator for this <paramref name="widget" /> in <paramref name="accel-group" /> that causes <paramref name="accel_signal" /> to be emitted if the accelerator is activated.</summary>
        <param name="accel_signal">Widget signal to emit on accelerator activation.</param>
        <param name="accel_group">Accel group for this widget, added to its toplevel.</param>
        <param name="accel_key">GDK keyval of the accelerator.</param>
        <param name="accel_mods">Modifier key combination of the accelerator.</param>
        <param name="accel_flags">Flag accelerators.</param>
        <remarks>
          <para>
          The <paramref name="accel-group" /> needs to be added to the widget's toplevel via <see cref="M:Gtk.Window.AddAccelGroup" />, and the signal must be of type G_RUN_ACTION. Accelerators added through this function are not user changeable during runtime.
         </para>
          <para>
          Accelerators added through this function are not user changeable during runtime. If you want to support accelerators that can be changed by the user, use <see cref="M:Gtk.Window.SetAccelPath" /> instead.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Flags a <paramref name="widget" /> to be displayed.</summary>
        <remarks>
          <para>
          Any widget that isn't shown will not appear on the screen. If you want to show all the widgets in a container, it's easier to call <see cref="M:Gtk.Widget.ShowAll" /> on the container, instead of individually showing the widgets.
         </para>
          <para>
          Remember that you have to show the containers containing a widget, in addition to the widget itself, before it will appear onscreen. And that when a toplevel container is shown, it is immediately realized and mapped; other shown widgets are realized and mapped when their toplevel container is realized and mapped.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetScrollAdjustments">
      <MemberSignature Language="C#" Value="public bool SetScrollAdjustments (Gtk.Adjustment hadjustment, Gtk.Adjustment vadjustment);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hadjustment" Type="Gtk.Adjustment" />
        <Parameter Name="vadjustment" Type="Gtk.Adjustment" />
      </Parameters>
      <Docs>
        <summary>For <paramref name="widgets" /> that support scrolling, sets the scroll adjustments.</summary>
        <param name="hadjustment">An adjustment for horizontal scrolling, or <see langword="null" />.</param>
        <param name="vadjustment">An adjustment for vertical scrolling, or <see langword="null" />.</param>
        <returns>Returns <see langword="true" /> if the widget supports scrolling.</returns>
        <remarks>
          <para>
          For <paramref name="widgets" /> that don't support scrolling, does nothing and returns <see langword="false" />. <paramref name="Widgets" /> that don't support scrolling can be scrolled by placing them in a <see cref="T:Gtk.ViewPort" />, which does support scrolling.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreatePangoLayout">
      <MemberSignature Language="C#" Value="public Pango.Layout CreatePangoLayout (string text);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Pango.Layout</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Creates a new <see cref="T:Pango.Layout" /> with the appropriate colormap, font description, and base direction for drawing text for <paramref name="widget" />.</summary>
        <param name="text"> text to set on the layout (can be <see langword="null" />).</param>
        <returns>The new <see cref="T:Pango.Layout" />.</returns>
        <remarks>
          <para>
          If you keep a <see cref="T:Pango.Layout" /> created in this way around, in order notify the layout of changes to the base direction or font of this widget, you must call <see cref="M:Pango.Layout.ContextChanged" /> in response to the <see cref="F:Gtk.Widget.StyleSet" /> and <see cref="F:Gtk-Widget.DirectionChanged" /> signals for the widget.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetRcStyles">
      <MemberSignature Language="C#" Value="public void ResetRcStyles ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reset the styles of <paramref name="widget" /> and all descendents, so when they are looked up again, they get the correct values for the currently loaded RC file settings.</summary>
        <remarks>
          <para>
          This function is not useful for applications.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeRequest">
      <MemberSignature Language="C#" Value="public void SizeRequest (Gtk.Requisition requisition);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requisition" Type="Gtk.Requisition" />
      </Parameters>
      <Docs>
        <summary>Obtains the preferred size of a <paramref name="widget" />.</summary>
        <param name="requisition">A <see cref="T:Gtk.Requisition" /> to be filled in.</param>
        <remarks>
          <para>
          The container uses this information to arrange its child widgets and decide what size allocations to give them with <see cref="M:Gtk.Widget.SizeAllocate" />. You can also call this function from an application, with some caveats. Most notably, getting a size request requires the widget to be associated with a screen, because font information may be needed. Multihead-aware applications should keep this in mind.
         </para>
          <para>
          This function is typically used when implementing a <see cref="T:Gtk.Container" /> subclass. Also remember that the size request is not necessarily the size a widget will actually be allocated.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>For <paramref name="widgets" /> that can be "activated" (buttons, menu items, etc.) this function activates them.</summary>
        <returns>Returns <see langword="true" /> if the widget was activatable.</returns>
        <remarks>
          <para>
          Activation is what happens when you press Enter on a widget during key navigation; clicking a button, selecting a menu item, etc. If the <paramref name="widget" /> isn't activatable, the function returns <see langword="false" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifyBg">
      <MemberSignature Language="C#" Value="public void ModifyBg (Gtk.StateType state, Gdk.Color color);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="Gtk.StateType" />
        <Parameter Name="color" Type="Gdk.Color" />
      </Parameters>
      <Docs>
        <summary>Sets the background color for a <paramref name="widget" /> in a particular state.</summary>
        <param name="state">The state for which to set the background color.</param>
        <param name="color">The color to assign (does not need to be allocated), or <see langword="null" /> to undo the effect of previous calls of <see cref="M:Gtk.Widget.ModifyBg" />.</param>
        <remarks>
          <para>
          All other style values are left untouched. See also <see cref="M:Gtk.Widget.ModifyStyle" />. 
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessEvent">
      <MemberSignature Language="C#" Value="public bool ProcessEvent (Gdk.Event evnt);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evnt" Type="Gdk.Event" />
      </Parameters>
      <Docs>
        <summary>Rarely-used function. This function is used to emit the event signals on a <paramref name="widget" />.</summary>
        <param name="evnt">A <see cref="T:Gdk.Event" />.</param>
        <returns>Return from the event signal emission (<see langword="true" /> if the event was handled)</returns>
        <remarks>
          <para>
          If you want to synthesize an event though, don't use this function; instead, use <see cref="M:Gdk.Windowt.InvalidateRect" /> to invalidate a region of the window.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reverses the effects of <see cref="M:Gtk.Widget.Show" />, causing the <paramref name="widget" /> to be hidden (invisible to the user).</summary>
        <remarks>
          <para>
          Reverses the effects of <see cref="M:Gtk.Widget.Show" />, causing the widget to be hidden (invisible to the user).
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifyBase">
      <MemberSignature Language="C#" Value="public void ModifyBase (Gtk.StateType state, Gdk.Color color);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="Gtk.StateType" />
        <Parameter Name="color" Type="Gdk.Color" />
      </Parameters>
      <Docs>
        <summary>Sets the base color for a <paramref name="widget" /> in a particular state.</summary>
        <param name="state">The state for which to set the base color.</param>
        <param name="color">The color to assign (does not need to be allocated), or <see langword="null" /> to undo the effect of previous calls to of <see cref="M:Gtk.Widget.ModifyBase" />.</param>
        <remarks>
          <para>
          All other style values are left untouched. The base color is the background color used along with the text color (see <see cref="M:Gtk.Widget.ModifyText" />) for widgets such as <see cref="T:Gtk.Entry" /> and <see cref="T:Gtk.TextView" />. See also <see cref="M:Gtk.Widget.ModifyStyle" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAncestor">
      <MemberSignature Language="C#" Value="public Gtk.Widget GetAncestor (uint widget_type);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.Widget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="widget_type" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <summary>Gets the first ancestor of <paramref name="widget" /> with type <paramref name="widget_type" />.</summary>
        <param name="widget_type">Ancestor type.</param>
        <returns>The ancestor widget, or <see langword="null" /> if not found</returns>
        <remarks>
          <para>
          For example, <see cref="M:Gtk.Widget.GetAncestor" />(widget, GTK_TYPE_BOX) gets the first <see cref="T:Gtk.Box" /> that's an ancestor of <paramref name="widget" />. No reference will be added to the returned widget; it should not be unreferenced. See note about checking for a toplevel <see cref="T:Gtk.Window" /> in the docs for <see cref="M:Gtk.Widget.Toplevel" />. Note that unlike <see cref="M:Gtk.Widget.IsAncestor" />, <see cref="M:Gtk.Widget.GetAncestor" /> considers <paramref name="widget" /> to be an ancestor of itself.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetShapes">
      <MemberSignature Language="C#" Value="public void ResetShapes ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recursively resets the shape on  <paramref name="widget" /> and its descendants.</summary>
        <remarks>
          <para>
          Recursively resets the shape on this widget and its descendants.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifyStyle">
      <MemberSignature Language="C#" Value="public void ModifyStyle (Gtk.RcStyle style);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="style" Type="Gtk.RcStyle" />
      </Parameters>
      <Docs>
        <summary>Modifies style values on the <paramref name="widget" />.</summary>
        <param name="style">The <see cref="T:Gtk.RcStyle" /> holding the style modifications.</param>
        <remarks>
          <para>
          Modifications made using this technique take precedence over style values set via an RC file, however, they will be overriden if a <paramref name="style" /> is explicitely set on the <paramref name="widget" /> using <see cref="M:Gtk.Widget.StyleSet" />. The <see cref="T:Gtk.RcStyle" /> structure is designed so each field can either be set or unset, so it is possible, using this function, to modify some style values and leave the others unchanged.
         </para>
          <para>
          Note that modifications made with this function are not cumulative with previous calls to <see cref="M:Gtk.Widget.ModifyStyle" /> or with such functions as <see cref="M:Gtk.Widget.ModifyBg" />. If you wish to retain previous values, you must first call <see cref="M:Gtk.Widget.ModifierStyle" />, make your modifications to the returned <paramref name="style" />, then call <see cref="M:Gtk.Widget.ModifyStyle" /> with that <paramref name="style" />. On the other hand, if you first call <see cref="M:Gtk.Widget.ModifyStyle" />, subsequent calls to such functions <see cref="M:Gtk.Widget.ModifyFg" /> will have a cumulative effect with the initial modifications.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSizeRequest">
      <MemberSignature Language="C#" Value="public void SetSizeRequest (int width, int height);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Sets the minimum size of a <paramref name="widget" />; that is, the <paramref name="widget" />'s size request will be <paramref name="width" /> by <paramref name="height" />.</summary>
        <param name="width">Width <paramref name="widget" /> should request, or -1 to unset.</param>
        <param name="height">Weight <paramref name="widget" /> should request, or -1 to unset.</param>
        <remarks>
          <para>
          You can use this function to force a widget to be either larger or smaller than it normally would be. In most cases, <see cref="M:Gtk.Window.SetDefaultSize" /> is a better choice for toplevel windows than this function; setting the default size will still allow users to shrink the window. Setting the size request will force them to leave the window at least as large as the size request. When dealing with window sizes, <see cref="M:Gtk.Window.SetGeometryHints" /> can be a useful function as well.
         </para>
          <para>
          Note the inherent danger of setting any fixed size - themes, translations into other languages, different fonts, and user action can all change the appropriate size for a given widget. So, it's basically impossible to hardcode a size that will always be correct. The size request of a widget is the smallest size a widget can accept while still functioning well and drawing itself correctly. However in some strange cases a widget may be allocated less than its requested size, and in many cases a widget may be allocated more space than it requested. 
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MnemonicActivate">
      <MemberSignature Language="C#" Value="public bool MnemonicActivate (bool group_cycling);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="group_cycling" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="group_cycling">To be added: an object of type 'bool'</param>
        <returns>To be added: an object of type 'bool'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSizeRequest">
      <MemberSignature Language="C#" Value="public void GetSizeRequest (out int width, out int height);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32&amp;" />
        <Parameter Name="height" Type="System.Int32&amp;" />
      </Parameters>
      <Docs>
        <summary>Gets the size request that was explicitly set for the <paramref name="widget" /> using <see cref="M:Gtk.Widget.SetSizeRequest" />.</summary>
        <param name="width">Return location for width, or <see langword="null" />.</param>
        <param name="height">Return location for height, or <see langword="null" />.</param>
        <remarks>
          <para>
          A value of -1 stored in <paramref name="width" /> or <paramref name="height" /> indicates that that dimension has not been set explicitly and the natural requisition of the <paramref name="widget" /> will be used intead. See <see cref="M:Gtk.Widget.SetSizeRequest" />. To get the size a <paramref name="widget" /> will actually use, call <see cref="M:Gtk.Widget.SizeRequest" /> instead of this function.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccelerator">
      <MemberSignature Language="C#" Value="public bool RemoveAccelerator (Gtk.AccelGroup accel_group, uint accel_key, Gdk.ModifierType accel_mods);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accel_group" Type="Gtk.AccelGroup" />
        <Parameter Name="accel_key" Type="System.UInt32" />
        <Parameter Name="accel_mods" Type="Gdk.ModifierType" />
      </Parameters>
      <Docs>
        <summary>Removes an accelerator from <paramref name="widget" />, previously installed with <see cref="M:Gtk.Widget.AddAccelerator" />.</summary>
        <param name="accel_group">Accel group for this widget.</param>
        <param name="accel_key">GDK keyval of the accelerator.</param>
        <param name="accel_mods">Modifier key combination of the accelerator.</param>
        <returns>Returns whether an accelerator was installed and could be removed.</returns>
        <remarks>
          <para>
          Removes an accelerator from <paramref name="widget" />, previously installed with <see cref="M:Gtk.Widget.AddAccelerator" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unmap">
      <MemberSignature Language="C#" Value="public void Unmap ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes a <paramref name="widget" /> to be unmapped if it's currently mapped.</summary>
        <remarks>
          <para>
          This function is only for use in widget implementations.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Map">
      <MemberSignature Language="C#" Value="public void Map ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes a <paramref name="widget" /> to be mapped if it isn't already.</summary>
        <remarks>
          <para>
          This function is only for use in widget implementations.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegionIntersect">
      <MemberSignature Language="C#" Value="public Gdk.Region RegionIntersect (Gdk.Region region);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Region</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="Gdk.Region" />
      </Parameters>
      <Docs>
        <summary>Computes the intersection of a <paramref name="widget" />'s area and <paramref name="region" />, returning the intersection. </summary>
        <param name="region">A <see cref="T:Gdk.Region" />, in the same coordinate system as <paramref name="widget" />-&gt;allocation. That is, relative to <paramref name="widget" />-&gt;window for <see cref="F:Gtk.WidgetFlags.NoWindow" /> widgets; relative to the parent window of <paramref name="widget" />-&gt;window for widgets with their own window.</param>
        <returns> A newly allocated region holding the intersection of <paramref name="widget" /> and <paramref name="region" />. The coordinates of the return value are relative to <paramref name="widget" />-&gt;window for <see cref="F:Gtk.WidgetFlags.NoWindow" /> widgets, and relative to the parent window of <paramref name="widget" />-&gt;window for widgets with their own window.</returns>
        <remarks>
          <para>
          The result may be empty, use <see cref="M:Gdk.Region.Empty" /> to check.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueResize">
      <MemberSignature Language="C#" Value="public void QueueResize ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Flags a <paramref name="widget" /> to have its size renegotiated; should be called when a <paramref name="widget" /> for some reason has a new <see cref="M:Gtk.Widget.SizeRequest" />.</summary>
        <remarks>
          <para>
          This function is only for use in widget implementations. One example, when you change the text in a <see cref="T:Gtk.Label" />, it queues a resize to ensure there's enough space for the new text.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifyFont">
      <MemberSignature Language="C#" Value="public void ModifyFont (Pango.FontDescription font_desc);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="font_desc" Type="Pango.FontDescription" />
      </Parameters>
      <Docs>
        <summary>Sets the font to use for a <paramref name="widget" />.</summary>
        <param name="font_desc">The font description to use, or <see langword="null" /> to undo the effect of previous calls to <see cref="M:Gtk.Widget.ModifyFont" />.</param>
        <remarks>
          <para>
          All other style values are left untouched. See also <see cref="M:Gtk.Widget.ModifyStyle" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendExpose">
      <MemberSignature Language="C#" Value="public int SendExpose (Gdk.Event evnt);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evnt" Type="Gdk.Event" />
      </Parameters>
      <Docs>
        <summary>Very rarely-used function. This function is used to emit an <see cref="F:Gtk.Widget.ExposeEvent" /> signals on a <paramref name="widget" />.</summary>
        <param name="evnt">A <see cref="F:Gtk.Widget.ExposeEvent" />.</param>
        <returns>Return from the event signal emission (<see langword="true" /> if the event was handled).</returns>
        <remarks>
          <para>
          This function is not normally used directly. The only time it is used is when propagating an <see cref="F:Gtk.Widget.ExposeEvent" /> to a child <see cref="F:Gtk.WidgetFlags.NoWindow" /> widget, and that is normally done using <see cref="M:Gtk.Container.PropagateExpose" />. If you want to force an area of a window to be redrawn, use <see cref="M:Gdk.Window.InvalidateRect" /> or <see cref="M:Gdk.Window.InvalidateRegion" />. To cause the redraw to be done immediately, follow that call with a call to <see cref="M:Gdk.Window.ProcessUpdates" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unrealize">
      <MemberSignature Language="C#" Value="public void Unrealize ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes a <paramref name="widget" /> to be unrealized (frees all GDK resources associated with the widget).</summary>
        <remarks>
          <para>
          This function is only useful in widget implementations.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureStyle">
      <MemberSignature Language="C#" Value="public void EnsureStyle ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ensures that <paramref name="widget" /> has a style (<paramref name="widget" />-&gt;style).</summary>
        <remarks>
          <para>
          Not a very useful function; most of the time, if you want the style, the <paramref name="widget" /> is realized, and realized widgets are guaranteed to have a style already.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAncestor">
      <MemberSignature Language="C#" Value="public bool IsAncestor (Gtk.Widget ancestor);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="Gtk.Widget" />
      </Parameters>
      <Docs>
        <summary>Determines whether <paramref name="widget" /> is somewhere inside <paramref name="ancestor" />, possibly with intermediate containers.</summary>
        <param name="ancestor">Another <see cref="T:Gtk.Widget" />.</param>
        <returns>Returns <see langword="true" /> if ancestor contains widget as a child, grandchild, great grandchild, etc.</returns>
        <remarks>
          <para>
          Determines whether <paramref name="widget" /> is somewhere inside <paramref name="ancestor" />, possibly with intermediate containers.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEvents">
      <MemberSignature Language="C#" Value="public void AddEvents (int events);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="events" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Adds the events in the bitfield <paramref name="events" /> to the event mask for <paramref name="widget" />.</summary>
        <param name="events" />
        <remarks>
          <para>
          Adds the events in the bitfield <paramref name="events" /> to the event mask for <paramref name="widget" />. See <see cref="M:Gtk.Widget.Events" /> for details.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HideAll">
      <MemberSignature Language="C#" Value="public void HideAll ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recursively hides a <paramref name="widget" /> and any child <paramref name="widgets" />.</summary>
        <remarks>
          <para>
          Recursively hides a <paramref name="widget" /> and any child <paramref name="widgets" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThawChildNotify">
      <MemberSignature Language="C#" Value="public void ThawChildNotify ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reverts the effect of a previous call to <see cref="M:Gtk.Widget.FreezeChildNotify" />.</summary>
        <remarks>
          <para>
          Reverts the effect of a previous call to <see cref="M:Gtk.Widget.FreezeChildNotify" />. This causes all queued <see cref="F:Gtk.Widget.ChildNotified" /> signals on <paramref name="widget" /> to be emitted.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShapeCombineMask">
      <MemberSignature Language="C#" Value="public void ShapeCombineMask (Gdk.Bitmap shape_mask, int offset_x, int offset_y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="shape_mask" Type="Gdk.Bitmap" />
        <Parameter Name="offset_x" Type="System.Int32" />
        <Parameter Name="offset_y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Sets a shape for this <paramref name="widget" />'s GDK window. This allows for transparent windows etc., see <see cref="M:Gdk.Window.ShapeCombineMask" /> for more information.</summary>
        <param name="shape_mask">Shape to be added, or <see langword="null" /> to remove an existing shape.</param>
        <param name="offset_x">X position of shape mask with respect to the window.</param>
        <param name="offset_y">Y position of shape mask with respect to the window.</param>
        <remarks>
          <para>
          Sets a shape for this <paramref name="widget" />'s GDK window. This allows for transparent windows etc., see <see cref="M:Gdk.Window.ShapeCombineMask" /> for more information.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildNotify">
      <MemberSignature Language="C#" Value="public void ChildNotify (string child_property);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child_property" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Emits a <see cref="F:Gtk.Widget.ChildNotified" /> signal for the child property on <paramref name="widget" />.</summary>
        <param name="child_property">The name of a child property installed on the class of widget's parent.</param>
        <remarks>
          <para>
         Emits a <see cref="F:Gtk.Widget.ChildNotified" /> signal for the child property on <paramref name="widget" />.
        </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Destroy">
      <MemberSignature Language="C#" Value="public void Destroy ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Destroys a <paramref name="widget" />.</summary>
        <remarks>
          <para>
          Equivalent to <see cref="M:Gtk.Object.Destroy" />, except that you don't have to cast the <paramref name="widget" /> to <see cref="T:Gtk.Object" />. When a <paramref name="widget" /> is destroyed, it will break any references it holds to other objects. If the <paramref name="widget" /> is inside a container, the <paramref name="widget" /> will be removed from the container. If the widget is a toplevel (derived from <see cref="T:Gtk.Window" />), it will be removed from the list of toplevels, and the reference GTK+ holds to it will be removed. 
         </para>
          <para>
          Removing a widget from its container or the list of toplevels results in the <paramref name="widget" /> being finalized, unless you've added additional references to the <paramref name="widget" /> with <see cref="M:Glib.Object.Ref" />.In most cases, only toplevel widgets (windows) require explicit destruction, because when you destroy a toplevel its children will be destroyed as well.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreezeChildNotify">
      <MemberSignature Language="C#" Value="public void FreezeChildNotify ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops emission of <see cref="F:Gtk.Widget.ChildNotified" /> signals on <paramref name="widget" />.</summary>
        <remarks>
          <para>
          The signals are queued until <see cref="M:Gtk.Widget.ThawChildNotify" /> is called on <paramref name="widget" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeAllocate">
      <MemberSignature Language="C#" Value="public void SizeAllocate (Gdk.Rectangle allocation);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allocation" Type="Gdk.Rectangle" />
      </Parameters>
      <Docs>
        <summary>This function is only used by <see cref="T:Gtk.Container" /> subclasses, to assign a size and position to their child widgets.</summary>
        <param name="allocation">A position and size to be allocated to <paramref name="widget" />.</param>
        <remarks>
          <para>
          This fuction is only used by <see cref="T:Gtk.Container" /> subclasses, to assign a size and position to their child widgets.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="protected virtual void Finalize ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disposes the resources associated with the object.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Widget (IntPtr raw);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="raw" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <summary>Internal constructor</summary>
        <param name="raw">Pointer to the C object.</param>
        <returns>An instance of Widget, wrapping the C object.</returns>
        <remarks>
          <para>This is an internal constructor, and should not be used by user code.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Widget ();" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>A constructor.</summary>
        <returns>An instance of <see cref="T:Gtk.Widget" />.</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="DefaultVisual">
      <MemberSignature Language="C#" Value="public static Gdk.Visual DefaultVisual { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Visual</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtains the visual of the default colormap.</summary>
        <returns>Returns a visual of the default colormap.</returns>
        <remarks>
          <para>
          Not really useful; used to be useful before <see cref="M:Gdk.Colormap.GetVisual" /> existed.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyle">
      <MemberSignature Language="C#" Value="public static Gtk.Style DefaultStyle { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtains the default style used by all widgets initially.</summary>
        <returns>Returns the default style. This <see cref="T:Gtk.Style" /> object is owned by GTK+ and should not be modified or freed.</returns>
        <remarks>
          <para>
          Returns the default style used by all widgets initially.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultColormap">
      <MemberSignature Language="C#" Value="public static Gdk.Colormap DefaultColormap { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Colormap</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Gdk.Colormap" />
      </Parameters>
      <Docs>
        <summary>Sets or obtains the default colormap to use when creating widgets.</summary>
        <param name="value">A colormap (see <see cref="T:Gdk.Colormap" />).</param>
        <returns>A <see cref="T:Gdk.Colormap" />.</returns>
        <remarks>
          <para>
            <see cref="M:Gtk.Widget.PushColormap" /> is a better function to use if you only want to affect a few widgets, rather than all widgets.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultDirection">
      <MemberSignature Language="C#" Value="public static Gtk.TextDirection DefaultDirection { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Gtk.TextDirection" />
      </Parameters>
      <Docs>
        <summary>Sets or obtains the default reading direction for widgets.</summary>
        <param name="value">A <see cref="P:Gtk.Widget.TextDirection" />.</param>
        <returns>A <see cref="P:Gtk.Widget.TextDirection" />.</returns>
        <remarks>
          <para>
          Where the direction has not been explicitly set by <see cref="P:Gtk.Widget.Direction" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GType">
      <MemberSignature Language="C#" Value="public static uint GType { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The GLib Type for Gtk.Widget</summary>
        <returns>The GLib Type for the Gtk.Widget class.</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GdkWindow">
      <MemberSignature Language="C#" Value="public Gdk.Window GdkWindow { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added</summary>
        <returns>To be added: an object of type 'Gdk.Window'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Allocation">
      <MemberSignature Language="C#" Value="public Gdk.Rectangle Allocation { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added</summary>
        <returns>To be added: an object of type 'Gdk.Rectangle'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessible">
      <MemberSignature Language="C#" Value="public Atk.Object Accessible { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Atk.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtains the default reading direction for widgets.</summary>
        <returns>A <see cref="T:Atk.Object" />.</returns>
        <remarks>Obtains the default reading direction for widgets.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Direction">
      <MemberSignature Language="C#" Value="public Gtk.TextDirection Direction { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Gtk.TextDirection" />
      </Parameters>
      <Docs>
        <summary>Sets or obtains the reading direction on a particular <paramref name="widget" />.</summary>
        <param name="value">A <see cref="T:Gtk.TextDirection" />.</param>
        <returns>The reading direction for the widget.</returns>
        <remarks>
          <para>
          This direction controls the primary direction for widgets containing text, and also the direction in which the children of a container are packed. The ability to set the direction is present in order so that correct localization into languages with right-to-left reading directions can be done. Generally, applications will let the default reading direction present, except for containers where the containers are arranged in an order that is explicitely visual rather than logical (such as buttons for text justification). If the direction is set none, then the value set by <see cref="P:Gtk.Widget.DefaultDirection" /> will be used.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Colormap">
      <MemberSignature Language="C#" Value="public Gdk.Colormap Colormap { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Colormap</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Gdk.Colormap" />
      </Parameters>
      <Docs>
        <summary>Sets or obtains the colormap that will be used to render <paramref name="widget" />.</summary>
        <param name="value">A colormap (see <see cref="T:Gdk.Colormap" />).</param>
        <returns>A <see cref="T:Gdk.Colormap" />.</returns>
        <remarks>
          <para>
          Widget must not have been previously realized.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildVisible">
      <MemberSignature Language="C#" Value="public bool ChildVisible { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>Sets or obtains whether <paramref name="widget" /> should be mapped along with its when its parent is mapped and <paramref name="widget" /> has been shown with <see cref="M:Gtk.Widget.Show" />.</summary>
        <param name="value">If <see langword="true" />, <paramref name="widget" /> should be mapped along with its parent.</param>
        <returns>Returns <see langword="true" /> if the widget is mapped with the parent.</returns>
        <remarks>
          <para>
          The child visibility can be set for widget before it is added to a container with <see cref="P:Gtk.Widget.Parent" />, to avoid mapping children unnecessary before immediately unmapping them. However it will be reset to its default state of <see langword="true" /> when the widget is removed from a container. 
         </para>
          <para>
          Note that changing the child visibility of a widget does not queue a resize on the widget. Most of the time, the size of a widget is computed from all visible children, whether or not they are mapped. If this is not the case, the container can queue a resize itself. This function is only useful for container implementations and never should be called by an application.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositeName">
      <MemberSignature Language="C#" Value="public string CompositeName { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Sets or obtains a <paramref name="widget" /> composite name.</summary>
        <param name="value">The name to set.</param>
        <returns>The composite name of <paramref name="widget" />, or <see langword="null" /> if <paramref name="widget" /> is not a composite child. The string should not be freed when it is no longer needed.</returns>
        <remarks>
          <para>
          The widget must be a composite child of its parent; see <see cref="M:Gtk.Widget.PushCompositeChild" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Toplevel">
      <MemberSignature Language="C#" Value="public Gtk.Widget Toplevel { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.Widget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtains the topmost widget in the container hierarchy <paramref name="widget" /> is a part of.</summary>
        <returns>The topmost ancestor of <paramref name="widget" />, or <paramref name="widget" /> itself if there's no ancestor.</returns>
        <remarks>
          <para>
          Note the difference in behavior against <see cref="P:Gtk.Widget.GetAncestor" />, would return <see langwod="null" /> if <paramref name="widget" /> wasn't inside a toplevel window, and if the window was inside a GtkWindow-derived widget which was in turn inside the toplevel <see cref="T:Gtk.Window" />. While the second case may seem unlikely, it actually happens when a <see cref="T:Gtk.Plug" /> is embedded inside a <see cref="T:Gtk.Socket" /> within the same application. To reliably find the toplevel <see cref="T:Gtk.Window" />, use <see cref="P:Gtk.Widget.TopLevel" /> and check if the <see cref="F:Gtk.WidgetFlags.TopLevel" /> flag is set on the result.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RedrawOnAllocate">
      <MemberSignature Language="C#" Value="public bool RedrawOnAllocate { set; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>Sets whether a <paramref name="widget" /> size allocation changes, the entire <paramref name="widget" /> is queued for drawing.</summary>
        <param name="value">
          <see langword="true" /> the entire widget will be redrawn when it is allocated to a new size. <see langword="false" /> only the new portion of the widget will be redrawn.</param>
        <returns>Returns <see langword="true" /> because it is on by Default, but returns <see langword="false" /> if you turn it off.</returns>
        <remarks>
          <para>
           By default, this setting is <see langword="true" /> and the entire <paramref name="widget" /> is redrawn on every size change. If your widget leaves the upper left are unchanged when made bigger, turning this setting on will improve performance.
         </para>
          <para>
           Note that for <see cref="F:Gtk.WidgetFlags.NoWindow" /> widgets setting this flag to <see langword="false" /> turns off all allocation on resizing: the widget will not even redraw if its position changes; this is to allow containers that don't draw anything to avoid excess invalidations. If you set this flag on a <see cref="F:Gtk.WidgetFlags.NoWindow" /> widget that does draw on <paramref name="widget" />-&gt;window, you are responsible for invalidating both the old and new allocation of the <paramref name="widget" /> when the widget is moved and responsible for invalidating regions newly when the <paramref name="widget" /> increases size.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="public bool DoubleBuffered { set; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>Use this function to turn off the double buffering.</summary>
        <param name="value">
          <see langword="true" /> is on by Default, <see langword="false" /> if you want to turn off double buffering no use call for true because it is default.</param>
        <returns>Returns <see langword="true" /> because double buffering is on by Default, but returns <see langword="false" /> if you turn it off.</returns>
        <remarks>
          <para>
           Widgets are double buffered by default, you can use this function to turn off the buffering. "Double buffered" simply means that <see cref="M:Gdk.Window.BeginPaintRegion" /> and <see cref="M:Gdk.Window.EndPaint" /> are called automatically around <see cref="F:Gtk.Widget.ExposeEvent" /> events sent to the widget. <see cref="M:Gdk.Window.BeginPaint" /> diverts all drawing to a <paramref name="widget" />'s window to an offscreen buffer, and <see cref="M:Gdk.Window.EndPaint" /> draws the buffer to the screen. The result is that users see the window update in one smooth step, and don't see individual graphics primitives being rendered. 
         </para>
          <para>
           In very simple terms, double buffered widgets don't flicker, so you would only use this function to turn off double buffering if you had special needs and really knew what you were doing.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public Gtk.Settings Settings { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.Settings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtains the settings object holding the settings (global property settings, RC file information, etc) used for this <paramref name="widget" />.</summary>
        <returns>The relevant <see cref="T:Gtk.Settings" /> object.</returns>
        <remarks>
          <para>
          Note that this function can only be called when the <see cref="T:Gtk.Widget" /> is attached to a toplevel, since the settings object is specific to a particular <see cref="T:Gdk.Screen" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentWindow">
      <MemberSignature Language="C#" Value="public Gdk.Window ParentWindow { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Gdk.Window" />
      </Parameters>
      <Docs>
        <summary>Sets or obtains <paramref name="widget" />'s parent window.</summary>
        <param name="value">The new parent window.</param>
        <returns>The parent window of <paramref name="widget" />.</returns>
        <remarks>
          <para>
          Sets or obtains <paramref name="widget" />'s parent window.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PangoContext">
      <MemberSignature Language="C#" Value="public Pango.Context PangoContext { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Pango.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtains a <see cref="T:Pango.Context" /> with the appropriate colormap, font description and base direction for <paramref name="widget" />.</summary>
        <returns></returns>
        <remarks>
          <para>
          Unlike the context returned by <see cref="M:Gtk.Widget.CreatePangoContext" />, this context is owned by the <paramref name="widget" /> (it can be used until the screen for the widget changes or the widget is removed from its toplevel), and will be updated to match any changes to the <paramref name="widget" />'s attributes. 
         </para>
          <para>
          If you create and keep a <see cref="T:Pango.Layout" /> using this context, you must deal with changes to the context by calling <see cref="T:Pango.Layout.ContextChanged" /> on the layout in response to the <see cref="F:Gtk.Widget.StyleSet" /> and <see cref="F:Gtk.Widget.DirectionChanged" /> signals for the <paramref name="widget" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public Gtk.StateType State { set; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.StateType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Gtk.StateType" />
      </Parameters>
      <Docs>
        <summary>Sets the state of a <paramref name="widget" /> (insensitive, prelighted, etc.).</summary>
        <param name="value">New state for <paramref name="widget" />.</param>
        <returns>The <see cref="T:Gtk.StateType" /> of the <paramref name="widget" />.</returns>
        <remarks>
          <para>
          Usually you should set the state using wrapper functions such as <see cref="P:Gtk.Widget.Sensitive" />. This function is for use in widget implementations.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visual">
      <MemberSignature Language="C#" Value="public Gdk.Visual Visual { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Visual</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtains the visual that will be used to render <paramref name="widget" />.</summary>
        <returns>The visual for <paramref name="widget" />.</returns>
        <remarks>
          <para>
          Obtains the visual that will be used to render <paramref name="widget" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifierStyle">
      <MemberSignature Language="C#" Value="public Gtk.RcStyle ModifierStyle { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.RcStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtains the current modifier style for the widget.(As set by <see cref="M:Gtk.Widget.ModifyStyle" />)</summary>
        <returns>The modifier style for the widget. This rc style is owned by the widget.</returns>
        <remarks>
          <para>
          If no style has previously set, a new <see cref="T:Gtk.RcStyle" /> will be created with all values unset, and set as the modifier style for the widget. If you make changes to this rc style, you must call <see cref="M:Gtk.Widget.ModifyStyle" />, passing in the returned rc style, to make sure that your changes take effect.
         </para>
          <para>
          Caution: passing the style back to <see cref="M:Gtk.Widget.ModifyStyle" /> will normally end up destroying it, because <see cref="M:Gtk.Widget.ModifyStyle" /> copies the passed-in style and sets the copy as the new modifier style, thus dropping any reference to the old modifier style. Add a reference to the modifier style if you want to keep it alive.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'bool'</param>
        <returns>To be added: an object of type 'bool'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthRequest">
      <MemberSignature Language="C#" Value="public int WidthRequest { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'int'</param>
        <returns>To be added: an object of type 'int'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sensitive">
      <MemberSignature Language="C#" Value="public bool Sensitive { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'bool'</param>
        <returns>To be added: an object of type 'bool'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="public int Events { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'int'</param>
        <returns>To be added: an object of type 'int'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceivesDefault">
      <MemberSignature Language="C#" Value="public bool ReceivesDefault { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'bool'</param>
        <returns>To be added: an object of type 'bool'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasFocus">
      <MemberSignature Language="C#" Value="public bool HasFocus { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'bool'</param>
        <returns>To be added: an object of type 'bool'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtensionEvents">
      <MemberSignature Language="C#" Value="public Gdk.ExtensionMode ExtensionEvents { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.ExtensionMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Gdk.ExtensionMode" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'Gdk.ExtensionMode'</param>
        <returns>To be added: an object of type 'Gdk.ExtensionMode'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasDefault">
      <MemberSignature Language="C#" Value="public bool HasDefault { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'bool'</param>
        <returns>To be added: an object of type 'bool'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositeChild">
      <MemberSignature Language="C#" Value="public bool CompositeChild { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added</summary>
        <returns>To be added: an object of type 'bool'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanDefault">
      <MemberSignature Language="C#" Value="public bool CanDefault { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'bool'</param>
        <returns>To be added: an object of type 'bool'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFocus">
      <MemberSignature Language="C#" Value="public bool CanFocus { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'bool'</param>
        <returns>To be added: an object of type 'bool'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeightRequest">
      <MemberSignature Language="C#" Value="public int HeightRequest { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'int'</param>
        <returns>To be added: an object of type 'int'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppPaintable">
      <MemberSignature Language="C#" Value="public bool AppPaintable { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'bool'</param>
        <returns>To be added: an object of type 'bool'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public Gtk.Widget Parent { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.Widget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Gtk.Widget" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'Gtk.Widget'</param>
        <returns>To be added: an object of type 'Gtk.Widget'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'string'</param>
        <returns>To be added: an object of type 'string'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public Gtk.Style Style { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.Style</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Gtk.Style" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">To be added: an object of type 'Gtk.Style'</param>
        <returns>To be added: an object of type 'Gtk.Style'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnmapEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.UnmapEventHandler UnmapEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public event GtkSharp.FocusedHandler Focused;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentSet">
      <MemberSignature Language="C#" Value="public event GtkSharp.ParentSetHandler ParentSet;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyReleaseEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.KeyReleaseEventHandler KeyReleaseEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hidden">
      <MemberSignature Language="C#" Value="public event EventHandler Hidden;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionRequestEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.SelectionRequestEventHandler SelectionRequestEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectionChanged">
      <MemberSignature Language="C#" Value="public event GtkSharp.DirectionChangedHandler DirectionChanged;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Event">
      <MemberSignature Language="C#" Value="public event EventHandler Event;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event GtkSharp.DragLeaveHandler DragLeave;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.ScrollEventHandler ScrollEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisibilityNotifyEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.VisibilityNotifyEventHandler VisibilityNotifyEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStateEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.WindowStateEventHandler WindowStateEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Mapped">
      <MemberSignature Language="C#" Value="public event EventHandler Mapped;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragBegin">
      <MemberSignature Language="C#" Value="public event GtkSharp.DragBeginHandler DragBegin;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="HierarchyChanged">
      <MemberSignature Language="C#" Value="public event GtkSharp.HierarchyChangedHandler HierarchyChanged;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigureEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.ConfigureEventHandler ConfigureEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPressEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.KeyPressEventHandler KeyPressEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="MapEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.MapEventHandler MapEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusGrabbed">
      <MemberSignature Language="C#" Value="public event EventHandler FocusGrabbed;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="MotionNotifyEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.MotionNotifyEventHandler MotionNotifyEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event GtkSharp.StateChangedHandler StateChanged;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="NoExposeEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.NoExposeEventHandler NoExposeEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unrealized">
      <MemberSignature Language="C#" Value="public event EventHandler Unrealized;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ButtonReleaseEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.ButtonReleaseEventHandler ButtonReleaseEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionGet">
      <MemberSignature Language="C#" Value="public event GtkSharp.SelectionGetHandler SelectionGet;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeAllocated">
      <MemberSignature Language="C#" Value="public event GtkSharp.SizeAllocatedHandler SizeAllocated;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopupMenu">
      <MemberSignature Language="C#" Value="public event GtkSharp.PopupMenuHandler PopupMenu;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExposeEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.ExposeEventHandler ExposeEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Shown">
      <MemberSignature Language="C#" Value="public event EventHandler Shown;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionNotifyEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.SelectionNotifyEventHandler SelectionNotifyEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusInEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.FocusInEventHandler FocusInEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ButtonPressEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.ButtonPressEventHandler ButtonPressEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyNotifyEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.PropertyNotifyEventHandler PropertyNotifyEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="HelpShown">
      <MemberSignature Language="C#" Value="public event GtkSharp.HelpShownHandler HelpShown;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.ClientEventHandler ClientEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProximityInEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.ProximityInEventHandler ProximityInEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProximityOutEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.ProximityOutEventHandler ProximityOutEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DestroyEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.DestroyEventHandler DestroyEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionReceived">
      <MemberSignature Language="C#" Value="public event GtkSharp.SelectionReceivedHandler SelectionReceived;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDataGet">
      <MemberSignature Language="C#" Value="public event GtkSharp.DragDataGetHandler DragDataGet;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnterNotifyEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.EnterNotifyEventHandler EnterNotifyEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDataReceived">
      <MemberSignature Language="C#" Value="public event GtkSharp.DragDataReceivedHandler DragDataReceived;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMotion">
      <MemberSignature Language="C#" Value="public event GtkSharp.DragMotionHandler DragMotion;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeRequested">
      <MemberSignature Language="C#" Value="public event GtkSharp.SizeRequestedHandler SizeRequested;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="GrabNotify">
      <MemberSignature Language="C#" Value="public event GtkSharp.GrabNotifyHandler GrabNotify;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleSet">
      <MemberSignature Language="C#" Value="public event GtkSharp.StyleSetHandler StyleSet;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusOutEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.FocusOutEventHandler FocusOutEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildNotified">
      <MemberSignature Language="C#" Value="public event GtkSharp.ChildNotifiedHandler ChildNotified;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unmapped">
      <MemberSignature Language="C#" Value="public event EventHandler Unmapped;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnd">
      <MemberSignature Language="C#" Value="public event GtkSharp.DragEndHandler DragEnd;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionClearEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.SelectionClearEventHandler SelectionClearEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="MnemonicActivated">
      <MemberSignature Language="C#" Value="public event GtkSharp.MnemonicActivatedHandler MnemonicActivated;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event GtkSharp.DragDropHandler DragDrop;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveNotifyEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.LeaveNotifyEventHandler LeaveNotifyEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.DeleteEventHandler DeleteEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Realized">
      <MemberSignature Language="C#" Value="public event EventHandler Realized;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDataDelete">
      <MemberSignature Language="C#" Value="public event GtkSharp.DragDataDeleteHandler DragDataDelete;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Widget (GLib.Type gtype);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="gtype" Type="GLib.Type" />
      </Parameters>
      <Docs>
        <summary>Internal constructor</summary>
        <param name="gtype">GLib type for the type</param>
        <returns>Creates a new instance of Widget, using the GLib-provided type</returns>
        <remarks>
          <para>This is a constructor used by derivative types of <see cref="T:Gtk.Widget" /> that would have their own GLib type assigned to it.  This is not typically used by C# code.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size RequestSize { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">a <see cref="T:System.Drawing.Size" /></param>
        <returns>a <see cref="T:System.Drawing.Size" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="RootWindow">
      <MemberSignature Language="C#" Value="public Gdk.Window RootWindow { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added</summary>
        <returns>a <see cref="T:Gdk.Window" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Display">
      <MemberSignature Language="C#" Value="public Gdk.Display Display { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Display</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added</summary>
        <returns>a <see cref="T:Gdk.Display" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Screen">
      <MemberSignature Language="C#" Value="public Gdk.Screen Screen { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Screen</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added</summary>
        <returns>a <see cref="T:Gdk.Screen" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocus">
      <MemberSignature Language="C#" Value="public bool IsFocus { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>Determines if the <paramref name="widget" /> is the focus widget within its toplevel.</summary>
        <returns><see langword="true" /> if the widget is the focus widget.</returns>
        <remarks>
          <para>
          This does not mean that the <see cref="P:Gtk.Widget.HasFocus" /> flag is necessarily set; <see cref="P:Gtk.Widget.HasFocus" /> will only be set if the toplevel widget additionally has the global input focus.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScreenChanged">
      <MemberSignature Language="C#" Value="public event GtkSharp.ScreenChangedHandler ScreenChanged;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public bool Intersect (Gdk.Rectangle area, out Gdk.Rectangle intersection);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="area" Type="Gdk.Rectangle" />
        <Parameter Name="intersection" Type="Gdk.Rectangle&amp;" />
      </Parameters>
      <Docs>
        <summary>Computes the intersection of a <paramref name="widget" />'s area and <paramref name="area" />.</summary>
        <param name="area"> A rectangle.</param>
        <param name="intersection"> A rectangle to store intersection of <paramref name="widget" /> and <paramref name="area" />.</param>
        <returns><see langword="true" /> if there was an intersection.</returns>
        <remarks>
          <para>
          Computes the intersection of a <paramref name="widget" />'s area and <paramref name="area" />, storing the intersection in <paramref name="intersection" />, and returns <see langword="true" /> if there was an intersection. <paramref name="intersection" /> may be <see langword="null" /> if you're only interested in whether there was an intersection.
         </para>
        </remarks>
      </Docs>
   </Member>
    <Member MemberName="StyleGetProperty">
      <MemberSignature Language="C#" Value="public void StyleGetProperty (string property_name, out GLib.Value value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property_name" Type="System.String" />
        <Parameter Name="value" Type="GLib.Value&amp;" />
      </Parameters>
      <Docs>
        <summary>Gets the <paramref name="value" /> of a style property of <paramref name="widget" />.</summary>
        <param name="property_name">The name of a style property.</param>
        <param name="value">Location to return the property value.</param>
        <remarks>
          <para>
          Gets the <paramref name="value" /> of a style property of <paramref name="widget" />.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetClipboard">
      <MemberSignature Language="C#" Value="public Gtk.Clipboard GetClipboard (Gdk.Atom selection);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.Clipboard</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selection" Type="Gdk.Atom" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="selection">a <see cref="T:Gdk.Atom" /></param>
        <returns>a <see cref="T:Gtk.Clipboard" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPointer">
      <MemberSignature Language="C#" Value="public void GetPointer (out int x, out int y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32&amp;" />
        <Parameter Name="y" Type="System.Int32&amp;" />
      </Parameters>
      <Docs>
        <summary>Obtains the location of the mouse pointer in <paramref name="widget" /> coordinates.</summary>
        <param name="x">Return location for the X coordinate, or <see langword="null" />.</param>
        <param name="y">Return location for the Y coordinate, or <see langword="null" />.</param>
        <remarks>
          <para>
          Widget coordinates are a bit odd; for historical reasons, they are defined as <paramref name="widget" />-&gt;window coordinates for widgets that are not <see cref="F:Gtk.WidgetFlags.NoWindow" /> widgets, and are relative to <paramref name="widget" />-&gt;allocation.x, <paramref name="widget" />-&gt;allocation.y for widgets that are <see cref="F:Gtk.WidgetFlags.NoWindow" /> widgets.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslateCoordinates">
      <MemberSignature Language="C#" Value="public bool TranslateCoordinates (Gtk.Widget dest_widget, int src_x, int src_y, out int dest_x, out int dest_y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dest_widget" Type="Gtk.Widget" />
        <Parameter Name="src_x" Type="System.Int32" />
        <Parameter Name="src_y" Type="System.Int32" />
        <Parameter Name="dest_x" Type="System.Int32&amp;" />
        <Parameter Name="dest_y" Type="System.Int32&amp;" />
      </Parameters>
      <Docs>
        <summary>Translate coordinates relative to <paramref name="widget" />'s allocation to coordinates relative to <paramref name="dest_widget" />'s allocations.</summary>
        <param name="dest_widget">A <see cref="T:Gtk.Widget" />.</param>
        <param name="src_x">X position relative to source widget.</param>
        <param name="src_y">Y position relative to source widget.</param>
        <param name="dest_x">Location to store X position relative to <paramref name="dest_widget" />.</param>
        <param name="dest_y">Location to store Y position relative to <paramref name="dest_widget" />.</param>
        <returns>Returns <see langword="false" /> if either widget was not realized, or there was no common ancestor. In this case, nothing is stored in <paramref name="*dest_x" /> and <paramref name="*dest_y" />. Otherwise <see langword="true" />.</returns>
        <remarks>
          <para>
          In order to perform this operation, both widgets must be realized, and must share a common toplevel. 
         </para>
        </remarks>
      </Docs>
   </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public void Path (out uint path_length, out string path, out string path_reversed);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path_length" Type="System.UInt32&amp;" />
        <Parameter Name="path" Type="System.String&amp;" />
        <Parameter Name="path_reversed" Type="System.String&amp;" />
      </Parameters>
      <Docs>
        <summary>Obtains the full path to <paramref name="widget" />.</summary>
        <param name="path_length">Location to store length of the path, or <see langword="null" />.</param>
        <param name="path">Location to store allocated path string, or <see langword="null" />.</param>
        <param name="path_reversed">Location to store allocated reverse path string, or <see langword="null" />.</param>
        <remarks>
          <para>
          The path is simply the name of a <paramref name="widget" /> and all its parents in the container hierarchy, separated by periods. The name of a <paramref name="widget" /> comes from <see cref="P:Gtk.Widget.Name" />. Paths are used to apply styles to a <paramref name="widget" /> in gtkrc configuration files. Widget names are the type of the <paramref name="widget" /> by default (e.g. "<see cref="T:Gtk.Button" />") or can be set to an application-specific value with <see cref="P:Gtk.Widget.Name" />.
         </para>
          <para>
          By setting the name of a <paramref name="widget" />, you allow users or theme authors to apply styles to that specific <paramref name="widget" /> in their gtkrc file. <paramref name="path_reversed_p" /> fills in the path in reverse order, i.e. starting with <paramref name="widget" />'s name instead of starting with the name of <paramref name="widget" />'s outermost ancestor.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasScreen">
      <MemberSignature Language="C#" Value="public bool HasScreen ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <returns>a <see cref="T:System.Boolean" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassPath">
      <MemberSignature Language="C#" Value="public void ClassPath (out uint path_length, out string path, out string path_reversed);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path_length" Type="System.UInt32&amp;" />
        <Parameter Name="path" Type="System.String&amp;" />
        <Parameter Name="path_reversed" Type="System.String&amp;" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="path_length">a <see cref="T:System.UInt32&amp;" /></param>
        <param name="path">a <see cref="T:System.String&amp;" /></param>
        <param name="path_reversed">a <see cref="T:System.String&amp;" /></param>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
  </Members>
</Type>