<Type Name="Application" FullName="Gtk.Application">
  <TypeSignature Language="C#" Value="public class Application" Maintainer="John Luke" />
  <AssemblyInfo>
    <AssemblyName>gtk-sharp</AssemblyName>
    <AssemblyPublicKey>
    </AssemblyPublicKey>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the <link location="node:gtk-sharp/programming/threads">Gtk# Thread Programming</link> for details.</ThreadSafetyStatement>
  <Docs>
    <summary>Application class</summary>
    <remarks>
      <para>
	Provides the initialization and event loop iteration related
	methods for the Gtk# widget library.  Since Gtk# is an event 
	driven toolkit, Applications register callbacks against various
	events to handle user input. These callbacks are invoked from
	the main event loop when events are detected.
      </para>
      <example>
        <code lang="C#">
using Gtk;
using System;
using GLib;

public class HelloWorld  {

	public static int Main (string[] args)
	{
		Application.Init ();
		Gtk.Window win = new Gtk.Window ("Gtk# Hello World");
		win.DeleteEvent += new DeleteEventHandler (Window_Delete);
		win.ShowAll ();
		Application.Run ();
		return 0;
	}

	static void Window_Delete (object obj, DeleteEventArgs args)
	{
		SignalArgs sa = (SignalArgs) args;
		Application.Quit ();
		sa.RetVal = true;
	}
}
        </code>
      </example>
    </remarks>
  </Docs>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Members>
    <Member MemberName="Quit">
      <MemberSignature Language="C#" Value="public static void Quit ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quits the current main loop</summary>
        <remarks>
          <para>
	    Makes the innermost invocation of the main loop return when it regains control.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RunIteration">
      <MemberSignature Language="C#" Value="public static void RunIteration ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Runs a single iteration of the main loop.</summary>
        <remarks>
          <para>
	    Runs a single iteration of the main loop. If no events are
	    waiting to be processed Gtk# will block until the next
	    event is noticed.  If you do not want to block look at <see cref="M:Gtk.Application.RunIteration(System.Boolean)" /> or check if
	    any events are pending with <see cref="M:Gtk.Application.EventsPending()" /> first.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EventsPending">
      <MemberSignature Language="C#" Value="public static bool EventsPending ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Whether there are events on the queue</summary>
        <returns>
          <see langword="true" /> if events are available to be processed, <see langword="false" /> otherwise</returns>
        <remarks>
          <para>
	    Checks if any events are pending. This can be used to
	    update the GUI and invoke timeouts etc. while doing some
	    time intensive computation.
	  </para>
          <example>
            <code lang="C#">
void LongComputation ()
{
	while (!done){
	    ComputationChunk ();

    	// Flush pending events to keep the GUI reponsive
    	while (Application.EventsPending ())
		    Application.RunIteration ();
	}
}
	    </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Runs the main loop</summary>
        <remarks>
          <para>
	    Runs the main loop until <see cref="M:Gtk.Application.Quit()" /> is called. You can nest
	    calls to <see cref="M:Gtk.Application.Run()" />.  In that
	    case <see cref="M:Gtk.Application.Quit()" /> will make the
	    innermost invocation of the main loop return.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public static void Init (string progname, ref string [] args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progname" Type="System.String" />
        <Parameter Name="args" Type="System.String []&amp;" />
      </Parameters>
      <Docs>
        <summary>Initializes Gtk# for operation.</summary>
        <param name="progname">The name of your program</param>
        <param name="args">The arguments to pass to the toolkit</param>
        <remarks>
          <para>
	    Call this function before using any other Gtk# functions
	    in your GUI applications. It will initialize everything
	    needed to operate the toolkit.
	  </para>
          <para>
	    This function will terminate your program if it was unable
	    to initialize the GUI for some reason. If you want your
	    program to fall back to a textual interface you want to
	    call <see cref="M:Gtk.Application.InitCheck(System.String, System.String []&amp;)" /> instead.
	  </para>
          <para>
	    The args values will be modified after Gtk has removed the
	    command line options that it handles itself.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitCheck">
      <MemberSignature Language="C#" Value="public static bool InitCheck (string progname, ref string [] args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progname" Type="System.String" />
        <Parameter Name="args" Type="System.String []&amp;" />
      </Parameters>
      <Docs>
        <summary>Initializes Gtk# for operation, probes window system.</summary>
        <returns>true if the toolkit was initialized, false if the
        windowing system can not be initilized.</returns>
        <param name="progname">The name of your program</param>
        <param name="args">The arguments to pass to the toolkit</param>
        <remarks>
          <para>
	    You use this call to initialize Gtk# for your GUI
	    applications.  This method will allow your application to
	    be both GUI/text.  A true return value means that the
	    toolkit was initialized, a false value means that the
	    toolkit could not be initialized.  If you do not want to
	    do dual GUI/text applications, you can use <see cref="M:Gtk.Application.Init()" /> instead. 
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public static void Init ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initializes GTK+ for operation.</summary>
        <remarks>
          <para>
	    Call this function before using any other Gtk# functions
	    in your GUI applications. It will initialize everything
	    needed to operate the toolkit.
	  </para>
          <para>
	    This function will terminate your program if it was unable
	    to initialize the GUI for some reason. If you want your
	    program to fall back to a textual interface you want to
	    call <see cref="M:Gtk.Application.InitCheck(System.String, System.String []&amp;)" /> instead.
	  </para>
          <para>
	    If you want to pass arguments from the command line use
	    the <see cref="T:Gtk.Application.Init(System.String, System.String []&amp;)" />
	    method instead. 
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RunIteration">
      <MemberSignature Language="C#" Value="public static bool RunIteration (bool blocking);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>Runs a single iteration of the main loop.</summary>
        <param name="blocking">A boolean value, whether the iteration should block or not</param>
        <remarks>
          <para>
            Runs a single iteration of the main loop. If <paramref name="blocking" /> is <see langword="true" />, then if no events are
            waiting to be processed Gtk# will block until the next event is noticed; If <paramref name="blocking" /> is <see langword="false" />,
            then it if no events are waiting to be processed Gtk#, routine will return immediately.
          </para>
        </remarks>
        <returns>To be added.</returns>
      </Docs>
    </Member>
    <Member MemberName="CurrentEvent">
      <MemberSignature Language="C#" Value="public static Gdk.Event CurrentEvent { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Event</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the event currently taking place.</summary>
        <value>a <see cref="T:Gdk.Event" /></value>
        <remarks />
      </Docs>
    </Member>
  <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public static void Init (string progname, ref string[] args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progname" Type="System.String" />
        <Parameter Name="args" Type="System.String[]&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="progname">To be added.</param>
        <param name="args">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  <Member MemberName="InitCheck">
      <MemberSignature Language="C#" Value="public static bool InitCheck (string progname, ref string[] args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progname" Type="System.String" />
        <Parameter Name="args" Type="System.String[]&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="progname">To be added.</param>
        <param name="args">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
