<Type Name="Window" FullName="Gtk.Window">
  <TypeSignature Language="C#" Value="public class Window : Gtk.Bin, Implementor, IWrapper, IWrapper, IDisposable" Maintainer="Hector Gomez M" />
  <AssemblyInfo>
    <AssemblyName>gtk-sharp</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
    <Attributes />
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the <link location="node:gtk-sharp/programming/threads">Gtk# Thread Programming</link> for details.</ThreadSafetyStatement>
  <Docs>
    <summary>Toplevel <paramref name="widget" /> which can contain other widgets.</summary>
    <remarks>Toplevel <paramref name="widget" /> which can contain other widgets.</remarks>
  </Docs>
  <Base>
    <BaseTypeName>Gtk.Bin</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Atk.Implementor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>GLib.IWrapper</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>GLib.IWrapper</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes />
  <Members>
    <Member MemberName="ListToplevels">
      <MemberSignature Language="C#" Value="public static GLib.List ListToplevels ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>GLib.List</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a list of all existing toplevel windows.</summary>
        <returns>List of toplevel widgets.</returns>
        <remarks>
         <para>
	  The widgets in the list are not individually referenced. If you want to iterate through the list and perform actions involving callbacks that might destroy the widgets, you must call g_list_foreach (result, (GFunc)g_object_ref, <see langword="null" />) first, and then unref all the widgets afterwards.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginMoveDrag">
      <MemberSignature Language="C#" Value="public void BeginMoveDrag (int button, int root_x, int root_y, uint timestamp);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="button" Type="System.Int32" />
        <Parameter Name="root_x" Type="System.Int32" />
        <Parameter Name="root_y" Type="System.Int32" />
        <Parameter Name="timestamp" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <summary>Starts moving a <paramref name="window" />.</summary>
        <param name="button">Mouse button that initiated the drag.</param>
        <param name="root_x">X position where the user clicked to initiate the drag, in root window coordinates.</param>
        <param name="root_y">Y position where the user clicked to initiate the drag.</param>
        <param name="timestamp">Timestamp from the click event that initiated the drag.</param>
        <remarks>
         <para>
	  This method is used if an application has window movement grips. When GDK can support it, the window movement will be done using the standard mechanism for the window manager or windowing system. Otherwise, GDK will try to emulate window movement, potentially not all that well, depending on the windowing system.
         </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFrameDimensions">
      <MemberSignature Language="C#" Value="public void GetFrameDimensions (out int left, out int top, out int right, out int bottom);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="top" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="right" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bottom" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <summary>Retrieves the dimensions of the frame window for this toplevel.</summary>
        <param name="left">Location to store the width of the frame at the left, or <see langword="null" />.</param>
        <param name="top">Location to store the height of the frame at the top, or <see langword="null" />.</param>
        <param name="right">Location to store the width of the frame at the returns, or <see langword="null" />.</param>
        <param name="bottom">Location to store the height of the frame at the bottom, or <see langword="null" />.</param>
        <remarks>
         <para>
	  It will not return the size of the window border drawn by the window manager, which is the normal case when using a windowing system. See <see cref="M:Gdk.Window.GetFrameExtents" /> to get the standard window border extents.) See also <see cref="P:Gtk.Window.HasFrame" />, <see cref="M:Gtk.Window.SetFrameDimensions" />.
         </para>
	 <para>
	  Note: this is a special-purpose method intended for the framebuffer port; see <see cref="M:Gtk.Window.SetFrameDimensions" />.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Iconify">
      <MemberSignature Language="C#" Value="public void Iconify ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asks to iconify (i.e. minimize) the specified <paramref name="window" />.</summary>
        <remarks>
	 <para>
	  Note that you shouldn't assume the window is definitely iconified afterward, because other entities (e.g. the user or window manager) could deiconify it again, or there may not be a window manager in which case iconification isn't possible, etc. But normally the window will end up iconified. Just do not write code that crashes if not.
	 </para>
	 <para>
	  You can track iconification via the <see cref="F:Gtk.Widget.WindowStateEvent" /> event on <see cref="T:Gtk.Widget" />.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unstick">
      <MemberSignature Language="C#" Value="public void Unstick ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asks to unstick <paramref name="window" />, which means that it will appear on only one of the user's desktops.</summary>
        <remarks>
	 <para>
	  Note that you shouldn't assume the window is definitely unstuck afterward, because other entities (e.g. the user or window manager) could stick it again. But normally the window will end up stuck. Just do not write code that crashes if not.
	 </para>
	 <para>
	  You can track stickiness via the <see cref="F:Gtk.Widget.WindowStateEvent" /> event on <see cref="T:Gtk.Widget" />.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unmaximize">
      <MemberSignature Language="C#" Value="public void Unmaximize ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asks to unmaximize <paramref name="window" />.</summary>
        <remarks>
	 <para>
	  Note that you shouldn't assume the window is definitely unmaximized afterward, because other entities (e.g. the user or window manager) could maximize it again, and not all window managers honor requests to unmaximize. But normally the window will end up unmaximized. Just don't write code that crashes if not.
	 </para>
	 <para>
	  You can track maximization via the <see cref="F:Gtk.Widget.WindowStateEvent" /> event on <see cref="T:Gtk.Widget" />
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSize">
      <MemberSignature Language="C#" Value="public void GetSize (out int width, out int height);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="height" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <summary>Obtains the current size of <paramref name="window" />.</summary>
        <param name="width">Return location for width, or <see langword="null" />.</param>
        <param name="height">Return location for height, or <see langword="null" />.</param>
        <remarks>
	 <para>
	  If window is not onscreen, it returns the size GTK+ will suggest to the window manager for the initial window size (but this is not reliably the same as the size the window manager will actually select). The size obtained by <see cref="M:Gtk.Window.GetSize" /> is the last size received in a GdkEventConfigure, that is, GTK+ uses its locally-stored size, rather than querying the X server for the size. As a result, if you call <see cref="M:Gtk.Window.Resize" /> then immediately call <see cref="M:Gtk.Window.GetSize" />, the size would not have taken effect yet. After the window manager processes the resize request, GTK+ receives notification that the size has changed via a configure event, and the size of the window gets updated.
	 </para>
	 <para>
	  Note 1: Nearly any use of this method creates a race condition, because the size of the window may change between the time that you get the size and the time that you perform some action assuming that size is the current size. To avoid race conditions, connect to <see cref="F:Gtk.Widget.ConfigureEvent" /> on the window and adjust your size-dependent state to match the size delivered in the GdkEventConfigure.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultSize">
      <MemberSignature Language="C#" Value="public void GetDefaultSize (out int width, out int height);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="height" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <summary>Gets the default size of the <paramref name="window" />.</summary>
        <param name="width">Location to store the default width, or <see langword="null" />.</param>
        <param name="height">Location to store the default height, or <see langword="null" />.</param>
        <remarks>
	 <para>
	  A value of -1 for the width or height indicates that a default size has not been explicitly set for that dimension, so the "natural" size of the window will be used.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public void Resize (int width, int height);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Resizes the <paramref name="window" /> as if the user had done so, obeying geometry constraints.</summary>
        <param name="width">Width in pixels to resize the window to.</param>
        <param name="height">Height in pixels to resize the window to.</param>
        <remarks>
	 <para>
	  The default geometry constraint is that windows may not be smaller than their size request; to override this constraint, call <see cref="M:Gtk.Widget.SetSizeRequest" /> to set the window's request to a smaller value.
	 </para>
	 <para>
	  If <see cref="M:Gtk.Window.Resize" /> is called before showing a window for the first time, it overrides any default size set with <see cref="M:Gtk.Window.SetDefaultSize" />. Windows may not be resized smaller than 1 by 1 pixels.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateFocus">
      <MemberSignature Language="C#" Value="public bool ActivateFocus ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Activates the current focused <paramref name="widget" /> within the <paramref name="window" />.</summary>
        <returns><see langword="true" /> if a <paramref name="widget" /> got activated.</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="ParseGeometry">
      <MemberSignature Language="C#" Value="public bool ParseGeometry (string geometry);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="geometry" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Parses a standard X Window System geometry string.</summary>
        <param name="geometry"></param>
        <returns><see langword="true" /> if string was parsed successfully.</returns>
        <remarks>
	 <para>
	 <see cref="M:Gtk.Window.ParseGeometry" /> does work on all GTK+ ports including Win32 but is primarily intended for an X environment.
	 </para>
	 <para>
	  If either a size or a position can be extracted from the geometry string, <see cref="M:Gtk.Window.ParseGeometry" /> returns <see langword="true" /> and calls <see cref="M:Gtk.Window.SetDefaultSize" /> and/or <see cref="M:Gtk.Window.Move" /> to resize/move the window.
	 </para>
	 <para>
	  If <see cref="M:Gtk.Window.ParseGeometry" /> returns <see langword="true" />, it will also set the GDK_HINT_USER_POS and/or GDK_HINT_USER_SIZE hints indicating to the window manager that the size/position of the window was user-specified. This causes most window managers to honor the geometry.
	 </para>
	 <para>
	  Note that for <see cref="M:Gtk.Window.ParseGeometry" /> to work as expected, it has to be called when the window has its "final" size, i.e. after calling <see cref="M:Gtk.Widget.ShowAll" /> on the contents and <see cref="M:Gtk.Window.SetGeometryHints" /> on the window.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccelGroup">
      <MemberSignature Language="C#" Value="public void RemoveAccelGroup (Gtk.AccelGroup accel_group);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accel_group" Type="Gtk.AccelGroup" />
      </Parameters>
      <Docs>
        <summary>Reverses the effects of <see cref="M:Gtk.Window.AddAccelGroup" />.</summary>
        <param name="accel_group">A <see cref="T:Gtk.AccelGroup" />.</param>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="Stick">
      <MemberSignature Language="C#" Value="public void Stick ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asks to stick <paramref name="window" />, which means that it will appear on all user desktops.</summary>
        <remarks>
	 <para>
	  Note that you shouldn't assume the window is definitely stuck afterward, because other entities (e.g. the user or window manager) could unstick it again, and some window managers do not support sticking windows. But normally the window will end up stuck. Just don't write code that crashes if not.
	 </para>
	 <para>
	  You can track stickiness via the <see cref="F:Gtk.Widget.WindowStateEvent" /> event on GtkWidget. It's permitted to call this method before showing a window.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFrameDimensions">
      <MemberSignature Language="C#" Value="public void SetFrameDimensions (int left, int top, int right, int bottom);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="right" Type="System.Int32" />
        <Parameter Name="bottom" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>For windows with frames (see <see cref="P:Gtk.Window.HasFrame" />) this method can be used to change the size of the frame border.</summary>
        <param name="left">The width of the left border.</param>
        <param name="top">The height of the top border.</param>
        <param name="right">The width of the right border.</param>
        <param name="bottom">The height of the bottom border.</param>
        <remarks>
	 <para>
	  Note: this is a special-purpose method intended for the framebuffer port; see <see cref="P:Gtk.Window.HasFrame" />. It will have no effect on the window border drawn by the window manager, which is the normal case when using the X Window system.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMnemonic">
      <MemberSignature Language="C#" Value="public void AddMnemonic (uint keyval, Gtk.Widget target);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyval" Type="System.UInt32" />
        <Parameter Name="target" Type="Gtk.Widget" />
      </Parameters>
      <Docs>
        <summary>Adds a mnemonic to this <paramref name="window" />.</summary>
        <param name="keyval">The mnemonic.</param>
        <param name="target">The <paramref name="widget" /> that gets activated by the mnemonic.</param>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="BeginResizeDrag">
      <MemberSignature Language="C#" Value="public void BeginResizeDrag (Gdk.WindowEdge edge, int button, int root_x, int root_y, uint timestamp);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="edge" Type="Gdk.WindowEdge" />
        <Parameter Name="button" Type="System.Int32" />
        <Parameter Name="root_x" Type="System.Int32" />
        <Parameter Name="root_y" Type="System.Int32" />
        <Parameter Name="timestamp" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <summary>Starts resizing a <paramref name="window" />.</summary>
        <param name="edge">Position of the resize control.</param>
        <param name="button">Mouse button that initiated the drag.</param>
        <param name="root_x">X position where the user clicked to initiate the drag, in root window coordinates.</param>
        <param name="root_y">Y position where the user clicked to initiate the drag</param>
        <param name="timestamp">Timestamp from the click event that initiated the drag.</param>
        <remarks>
	 <para>
	  This method is used if an application has window resizing controls. When GDK can support it, the resize will be done using the standard mechanism for the window manager or windowing system. Otherwise, GDK will try to emulate window resizing, potentially not all that well, depending on the windowing system.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPosition">
      <MemberSignature Language="C#" Value="public void GetPosition (out int root_x, out int root_y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root_x" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="root_y" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <summary>This method returns the position you need to pass to <see cref="M:Gtk.Window.Move" /> to keep <paramref name="window" /> in its current position.</summary>
        <param name="root_x">Return location for X coordinate of gravity-determined reference point.</param>
        <param name="root_y">Return location for Y coordinate of gravity-determined reference point.</param>
        <remarks>
	 <para>
	  If you haven't changed the window gravity, its gravity will be GDK_GRAVITY_NORTH_WEST. This means that <see cref="M:Gtk.Window.GetPosition" /> gets the position of the top-left corner of the window manager frame for the window. <see cref="M:Gtk.Window.Move" /> sets the position of this same top-left corner.
	 </para>
	 <para>
	  <see cref="M:Gtk.Window.GetPosition" /> is not 100% reliable because the X Window System does not specify a way to obtain the geometry of the decorations placed on a window by the window manager. Thus GTK+ is using a "best guess" that works with most window managers.
	 </para>
	 <para>
	  Moreover, nearly all window managers are historically broken with respect to their handling of window gravity. So moving a window to its current position as returned by <see cref="M:Gtk.Window.GetPostion" /> tends to result in moving the window slightly. Window managers are slowly getting better over time.
	 </para>
	 <para>
	  If a window has gravity GDK_GRAVITY_STATIC the window manager frame is not relevant, and thus <see cref="M:Gtk.Window.GetPosition" /> will always produce accurate results. However you can't use static gravity to do things like place a window in a corner of the screen, because static gravity ignores the window manager decorations.
	 </para>
	 <para>
	  If you are saving and restoring your application's window positions, you should know that it's impossible for applications to do this without getting it somewhat wrong because applications do not have sufficient knowledge of window manager state. The Correct Mechanism is to support the session management protocol (see the "GnomeClient" object in the GNOME libraries for example) and allow the window manager to save your window sizes and positions.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="Deiconify">
      <MemberSignature Language="C#" Value="public void Deiconify ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asks to deiconify (i.e. unminimizw) the specified <paramref name="window" />.</summary>
        <remarks>
	 <para>
	  Note that you shouldn't assume the window is definitely deiconified afterward, because other entities (e.g. the user or window manager) could iconify it again before your code which assumes deiconification gets to run.
	 </para>
	 <para>
	  You can track iconification via the <see cref="F:Gtk.Widget.WindowStateEvent" /> event on GtkWidget. 
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="MnemonicActivate">
      <MemberSignature Language="C#" Value="public bool MnemonicActivate (uint keyval, Gdk.ModifierType modifier);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyval" Type="System.UInt32" />
        <Parameter Name="modifier" Type="Gdk.ModifierType" />
      </Parameters>
      <Docs>
        <summary>Activates the targets associated with the mnemonic.</summary>
        <param name="keyval">The mnemonic.</param>
        <param name="modifier">The modifiers.</param>
        <returns><see langword="true" /> if the activation is done.</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="ActivateDefault">
      <MemberSignature Language="C#" Value="public bool ActivateDefault ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Activates the default <paramref name="widget" /> for the <paramref name="window" />.</summary>
        <returns><see langword="true" /> if a <paramref name="widget" /> is activated.</returns>
        <remarks>
	 <para>
	  That is unless the current focused <paramref name="widget" /> has been configured to receive the default (see <see cref="F:Gtk.WidgetFlags.ReceivesDefault" />) action in which case the case the focused <paramref name="widget" /> is activated.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="Maximize">
      <MemberSignature Language="C#" Value="public void Maximize ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asks to maximize <paramref name="window" />, so that it becomes full-screen.</summary>
        <remarks>
	 <para>
	  Note that you shouldn't assume the window is definitely maximized afterward, because other entities (e.g. the user or window manager) could unmaximize it again, and not all window managers support maximization. But normally the window will end up maximized. Just don't write code that crashes if not.
	 </para>
	 <para>
	  You can track maximization via the <see cref="F:Gtk.Widget.WindowStateEvent" /> event on GtkWidget. It's permitted to call this method before showing a window, in which case the window will be maximized when it appears onscreen initially.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMnemonic">
      <MemberSignature Language="C#" Value="public void RemoveMnemonic (uint keyval, Gtk.Widget target);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyval" Type="System.UInt32" />
        <Parameter Name="target" Type="Gtk.Widget" />
      </Parameters>
      <Docs>
        <summary>Removes a mnemonic from this <paramref name="window" />.</summary>
        <param name="keyval">The mnemonic.</param>
        <param name="target">The <paramref name="widget" /> that gets activated by the mnemonic.</param>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="AddEmbeddedXid">
      <MemberSignature Language="C#" Value="public void AddEmbeddedXid (uint xid);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xid" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="xid">an object of type <see cref="T:System.UInt32" /></param>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetWmclass">
      <MemberSignature Language="C#" Value="public void SetWmclass (string wmclass_name, string wmclass_class);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wmclass_name" Type="System.String" />
        <Parameter Name="wmclass_class" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>It sets the X Window System "class" and "name" hints for a <paramref name="window" />. (Don't use this method.)</summary>
        <param name="wmclass_name">Window name hint.</param>
        <param name="wmclass_class">Window class hint.</param>
        <remarks>
	 <para>
	  According to the ICCCM, you should always set these to the same value for all windows in an application, and GTK+ sets them to that value by default, so calling this method is sort of pointless. However, you may want to call <see cref="P:Gtk.Window.Role" /> on each window in your application, for the benefit of the session manager. Setting the role allows the window manager to restore window positions when loading a saved session.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveEmbeddedXid">
      <MemberSignature Language="C#" Value="public void RemoveEmbeddedXid (uint xid);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xid" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="xid">an object of type <see cref="T:System.UInt32" /></param>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDefaultSize">
      <MemberSignature Language="C#" Value="public void SetDefaultSize (int width, int height);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Sets the default size of an object, with the specified width and height arguments.</summary>
        <param name="width">Width in pixels, or -1 to unset the default width.</param>
        <param name="height">Height in pixels, or -1 to unset the default height.</param>
        <remarks>
	 <para>
	  If the window's "natural" size (its size request) is larger than the default, the default will be ignored. More generally, if the default size does not obey the geometry hints for the window (<see cref="M:Gtk.Window.SetGeometryHints" /> can be used to set these explicitly), the default size will be clamped to the nearest permitted size.
	 </para>
	 <para>
	  Unlike <see cref="M:Gtk.Widget.SetSizeRequest" /> which sets a size request for a <paramref name="widget" /> and thus would keep users from shrinking the window, this method only sets the initial size, just as if the user had resized the window themselves. Users can still shrink the window again as they normally would. Setting a default size of -1 means to use the "natural" default size (the size request of the window). 
	 </para>
	 <para>
	  For more control over a window's initial size and how resizing works, investigate <see cref="M:Gtk.Window.SetGeometryHints" />.
	 </para>
	 <para>
	  For some uses, <see cref="M:Gtk.Window.Resize" /> is a more appropriate method. <see cref="M:Gtk.Window.Resize" /> changes the current size of the window, rather than the size to be used on initial display. <see cref="M:Gtk.Window.Resize" /> always affects the window itself, not the geometry widget. 
	 </para>
	 <para>
	  The default size of a window only affects the first time a window is shown; if a window is hidden and re-shown, it will remember the size it had prior to hiding, rather than using the default size.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Present">
      <MemberSignature Language="C#" Value="public void Present ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Presents a <paramref name="window" /> to the user.</summary>
        <remarks>
	 <para>
	  This may mean raising the window in the stacking order, deiconifying it, moving it to the current desktop, and/or giving it the keyboard focus, possibly dependent on the user's platform, window manager, and preferences. If window is hidden, this method calls <see cref="M:Gtk.Widget.Show" /> as well. 
	 </para>
	 <para>
	  This method should be used when the user tries to open a window that's already open. Say for example the preferences dialog is currently open, and the user chooses Preferences from the menu a second time; use <see cref="M:Gtk.Window.Present" /> to move the already-open dialog where the user can see it.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReshowWithInitialSize">
      <MemberSignature Language="C#" Value="public void ReshowWithInitialSize ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hides <paramref name="window" />, then reshows it, resetting the default size and position of the <paramref name="window" />.</summary>
        <remarks>
	 <para>
	  Used by GUI builders only.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public void Move (int x, int y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Asks the window manager to move <paramref name="window" /> to the given position.</summary>
        <param name="x">X coordinate to move window to.</param>
        <param name="y">Y coordinate to move window to.</param>
        <remarks>
	 <para>
	  Window managers are free to ignore this; most window managers ignore requests for initial window positions (instead using a user-defined placement algorithm) and honor requests after the window has already been shown.
	 </para>
	 <para>
	  Note: the position is the position of the gravity-determined reference point for the window. The gravity determines two things: first, the location of the reference point in root window coordinates; and second, which point on the window is positioned at the reference point. 
	 </para>
	 <para>
	  By default the gravity is GDK_GRAVITY_NORTH_WEST, so the reference point is simply the x, y supplied to <see cref="M:Gtk.Window.Move" />. The top-left corner of the window decorations (aka window frame or border) will be placed at <paramref name="x" />, <paramref name="y" />. Therefore, to position a window at the top left of the screen, you want to use the default gravity (which is GDK_GRAVITY_NORTH_WEST) and move the window to 0,0.
	 </para>
	 <para>
	  To position a window at the bottom right corner of the screen, you would set GDK_GRAVITY_SOUTH_EAST, which means that the reference point is at x + the window width and y + the window height, and the bottom-right corner of the window border will be placed at that reference point.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPosition">
      <MemberSignature Language="C#" Value="public void SetPosition (Gtk.WindowPosition position);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="Gtk.WindowPosition" />
      </Parameters>
      <Docs>
        <summary>Sets the position constraint for a <paramref name="window" />.</summary>
        <param name="position">A position constraint.</param>
        <remarks>
	 <para>
	  Is is used for placing the window in some area, depending on the <paramref name="position" /> constraint.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccelGroup">
      <MemberSignature Language="C#" Value="public void AddAccelGroup (Gtk.AccelGroup accel_group);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accel_group" Type="Gtk.AccelGroup" />
      </Parameters>
      <Docs>
        <summary>Associate <paramref name="accel_group" /> with <paramref name="window" />.</summary>
        <param name="accel_group">A <see cref="T:Gtk.AccelGroup" />.</param>
        <remarks>
	 <para>
	  Such that calling <see cref="T:Gtk.AccelGroupActivate" /> on <paramref name="window" /> will activate accelerators in <paramref name="accel_group" />.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetGeometryHints">
      <MemberSignature Language="C#" Value="public void SetGeometryHints (Gtk.Widget geometry_widget, Gdk.Geometry geometry, Gdk.WindowHints geom_mask);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="geometry_widget" Type="Gtk.Widget" />
        <Parameter Name="geometry" Type="Gdk.Geometry" />
        <Parameter Name="geom_mask" Type="Gdk.WindowHints" />
      </Parameters>
      <Docs>
        <summary>This method sets up hints about how a <paramref name="window" /> can be resized by the user.</summary>
        <param name="geometry_widget">Widget the geometry hints will be applied to.</param>
        <param name="geometry">Struct containing geometry information.</param>
        <param name="geom_mask">Mask indicating which struct fields should be paid attention to.</param>
        <remarks>
	 <para>
	  You can set a minimum and maximum size; allowed resize increments (e.g. for xterm, you can only resize by the size of a character); aspect ratios; and more. See <see cref="T:Gdk.Geometry" />.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="protected virtual void Finalize ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disposes the resources associated with the object.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window (IntPtr raw);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="raw" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <summary>Internal constructor</summary>
        <param name="raw">Pointer to the C object.</param>
        <returns>An instance of Window, wrapping the C object.</returns>
        <remarks>
	 <para>This is an internal constructor, and should not be used by user code.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window (Gtk.WindowType type);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="type" Type="Gtk.WindowType" />
      </Parameters>
      <Docs>
        <summary>Creates a new Window object, based on the <paramref name="type" />.</summary>
        <param name="type">A <see cref="T:Gtk.WindowType" />.</param>
        <returns>A <see cref="T:Gtk.Window" />.</returns>
        <remarks>
	 <para>
	  Creates a new Window object, wich can be of type TopLevel ( most of the cases ) or PopUp. Take care with the use of PopUp type, since it is not controlled by the window manager.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Window ();" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>Internal constructor</summary>
        <returns>an object of type <see cref="T:Gtk.Window" /></returns>
        <remarks>This is an internal constructor, and should not be used by user code.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window (string title);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Creates a new TopLevel Window object, with <paramref name="string" /> as the title.</summary>
        <param name="title">A string.</param>
        <returns>A <see cref="T:Gtk.Window" />.</returns>
        <remarks>
	 <para>
	  Creates a new TopLevel Window object, using <paramref name="string" /> as the title. You get the same if you use the public Window ( Gtk.WindowType type ) constructor and later set the string Title property.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultIconList">
      <MemberSignature Language="C#" Value="public static GLib.List DefaultIconList { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>GLib.List</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>Sets or obtains the icon list to be used as fallback for windows that haven't had <see cref="M:Gtk.Window.IconList" /> called on them to set up a window-specific icon list.</summary>
        <param name="value">A list of <see cref="T:Gdk.Pixbuf" />.</param>
        <returns>A copy of  default icon list.</returns>
        <remarks>
	 <para>
	  This method allows you to set up the icon for all windows in your app at once. 
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="GType">
      <MemberSignature Language="C#" Value="public static uint GType { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:GLib.Type" /> for <see cref="T:Gtk.Window" /></summary>
        <returns>The <see cref="T:GLib.Type" /> for the <see cref="T:Gtk.Window" /> class.</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public Gtk.Widget Default { set; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.Widget</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>Sets or unsets the default <paramref name="widget" /> for a <see cref="T:Gtk.Window" /> about.</summary>
        <param name="value">Widget to be the default, or <see langword="null" /> to unset the default <paramref name="widget" /> for the toplevel.</param>
        <returns>A <see cref="T:Gtk.Widget" />.</returns>
        <remarks>
	 <para>
	  The default <paramref name="widget" /> is the widget that's activated when the user presses Enter in a dialog (for example). When setting (rather than unsetting) the default <paramref name="widget" /> it's generally easier to call <see cref="M:Gtk.Widget.GrabFocus" /> on the <paramref name="widget" />. Before making a default <paramref name="widget" />, you must set the <see cref="F:Gtk.WidgetFlags.CanDefault" /> flag on the <paramref name="widget" /> you'd like to make the default.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasFrame">
      <MemberSignature Language="C#" Value="public bool HasFrame { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:System.Boolean" /></param>
        <returns>an object of type <see cref="T:System.Boolean" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Gravity">
      <MemberSignature Language="C#" Value="public Gdk.Gravity Gravity { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Gravity</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:Gdk.Gravity" /></param>
        <returns>an object of type <see cref="T:Gdk.Gravity" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="MnemonicModifier">
      <MemberSignature Language="C#" Value="public Gdk.ModifierType MnemonicModifier { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.ModifierType</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:Gdk.ModifierType" /></param>
        <returns>an object of type <see cref="T:Gdk.ModifierType" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHint">
      <MemberSignature Language="C#" Value="public Gdk.WindowTypeHint TypeHint { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.WindowTypeHint</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:Gdk.WindowTypeHint" /></param>
        <returns>an object of type <see cref="T:Gdk.WindowTypeHint" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransientFor">
      <MemberSignature Language="C#" Value="public Gtk.Window TransientFor { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.Window</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:Gtk.Window" /></param>
        <returns>an object of type <see cref="T:Gtk.Window" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public Gtk.Widget Focus { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.Widget</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:Gtk.Widget" /></param>
        <returns>an object of type <see cref="T:Gtk.Widget" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="IconList">
      <MemberSignature Language="C#" Value="public GLib.List IconList { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>GLib.List</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:GLib.List" /></param>
        <returns>an object of type <see cref="T:GLib.List" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Role">
      <MemberSignature Language="C#" Value="public string Role { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:System.String" /></param>
        <returns>an object of type <see cref="T:System.String" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Decorated">
      <MemberSignature Language="C#" Value="public bool Decorated { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>Sets if a Window will be decorated or not ( borderless ).</summary>
        <param name="value">A <see cref="T:System.Boolean" />.</param>
        <returns><see langword="true" /> to decorate the window or if the window has been set to have decorations.</returns>
        <remarks>
	 <para>
	  With this property you control if a window will be decorated or not.
	 </para>
	 <para>
	  By default, windows are decorated with a title bar and resize controls. Some window managers allow to disable these decorations, creating a borderless Window. If you set this property as false, Gtk# will try to convince the window manager not to decorate the Window.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resizable">
      <MemberSignature Language="C#" Value="public bool Resizable { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>Sets if a Window will be resizable by the user or not.</summary>
        <param name="value">an object of type <see cref="T:System.Boolean" /></param>
        <returns>an object of type <see cref="T:System.Boolean" /></returns>
        <remarks>
	 <para>
	  By default, windows are resizable, so you can change the size of them. But if you set this property to false, the user won't be able to change the size of them.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowPosition">
      <MemberSignature Language="C#" Value="public Gtk.WindowPosition WindowPosition { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.WindowPosition</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>Property used for setting/getting the window position.</summary>
        <param name="value">an object of type <see cref="T:Gtk.WindowPosition" /></param>
        <returns>an object of type <see cref="T:Gtk.WindowPosition" /></returns>
        <remarks>
	 <para>
	  This property will alow you to define where a Window must be displayed on the screen. It work with the Gtk.WindowPosition enum, soy maybe you should check it before use it.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultHeight">
      <MemberSignature Language="C#" Value="public int DefaultHeight { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>Property used for defining the default height of a window.</summary>
        <param name="value">an object of type <see cref="T:System.Int32" /></param>
        <returns>an object of type <see cref="T:System.Int32" /></returns>
        <remarks>
	 <para>
	  This property will allow you to define the default height for your Window. It only define the default one, so if the Window is resized, it won't be able to do anything.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DestroyWithParent">
      <MemberSignature Language="C#" Value="public bool DestroyWithParent { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:System.Int32" /></param>
        <returns>an object of type <see cref="T:System.Int32" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Modal">
      <MemberSignature Language="C#" Value="public bool Modal { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:System.Boolean" /></param>
        <returns>an object of type <see cref="T:System.Boolean" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowGrow">
      <MemberSignature Language="C#" Value="public bool AllowGrow { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:System.Boolean" /></param>
        <returns>an object of type <see cref="T:System.Boolean" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>Property used for setting the Window Title.</summary>
        <param name="value">an object of type <see cref="T:System.String" /></param>
        <returns>an object of type <see cref="T:System.String" /></returns>
        <remarks>
	 <para>
	  This property will allow you to set the Window Title. The Title of a window will be displayed in its title bar. Since the title bar is rendered by the window managers on X Window System, the way it appears will depend on the user preferences. This title should help the users to distinguish a window from others opened. A good title will have the application name an the actual document, for example.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public Gtk.WindowType Type { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.WindowType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added</summary>
        <returns>an object of type <see cref="T:Gtk.WindowType" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultWidth">
      <MemberSignature Language="C#" Value="public int DefaultWidth { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:System.Int32" /></param>
        <returns>an object of type <see cref="T:System.Int32" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public Gdk.Pixbuf Icon { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Pixbuf</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:Gdk.Pixbuf" /></param>
        <returns>an object of type <see cref="T:Gdk.Pixbuf" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowShrink">
      <MemberSignature Language="C#" Value="public bool AllowShrink { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">an object of type <see cref="T:System.Boolean" /></param>
        <returns>an object of type <see cref="T:System.Boolean" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeysChanged">
      <MemberSignature Language="C#" Value="public event EventHandler KeysChanged;" />
      <MemberType>Event</MemberType>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public event GtkSharp.MoveFocusHandler MoveFocus;" />
      <MemberType>Event</MemberType>
      <ReturnValue>
        <ReturnType>GtkSharp.MoveFocusHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public event GtkSharp.SetFocusHandler SetFocus;" />
      <MemberType>Event</MemberType>
      <ReturnValue>
        <ReturnType>GtkSharp.SetFocusHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultActivated">
      <MemberSignature Language="C#" Value="public event EventHandler DefaultActivated;" />
      <MemberType>Event</MemberType>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusActivated">
      <MemberSignature Language="C#" Value="public event EventHandler FocusActivated;" />
      <MemberType>Event</MemberType>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameEvent">
      <MemberSignature Language="C#" Value="public event GtkSharp.FrameEventHandler FrameEvent;" />
      <MemberType>Event</MemberType>
      <ReturnValue>
        <ReturnType>GtkSharp.FrameEventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Window (GLib.Type gtype);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="gtype" Type="GLib.Type" />
      </Parameters>
      <Docs>
        <summary>Internal constructor</summary>
        <param name="gtype">GLib type for the type</param>
        <returns>Creates a new instance of Window, using the GLib-provided type</returns>
        <remarks>
	 <para>
	  This is a constructor used by derivative types of <see cref="T:Gtk.Window" /> that would have their own GLib type assigned to it.  This is not typically used by C# code.
	 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoStartupNotification">
      <MemberSignature Language="C#" Value="public static bool AutoStartupNotification { set; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">a <see cref="T:System.Boolean" /></param>
        <returns>a <see cref="T:System.Boolean" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added</summary>
        <returns>a <see cref="T:System.Drawing.Size" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Position { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added</summary>
        <returns>a <see cref="T:System.Drawing.Size" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size DefaultSize { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">a <see cref="T:System.Drawing.Size" /></param>
        <returns>a <see cref="T:System.Drawing.Size" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Screen">
      <MemberSignature Language="C#" Value="public Gdk.Screen Screen { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Screen</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">a <see cref="T:Gdk.Screen" /></param>
        <returns>a <see cref="T:Gdk.Screen" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added</summary>
        <returns>a <see cref="T:System.Boolean" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasToplevelFocus">
      <MemberSignature Language="C#" Value="public bool HasToplevelFocus { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added</summary>
        <returns>a <see cref="T:System.Boolean" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipPagerHint">
      <MemberSignature Language="C#" Value="public bool SkipPagerHint { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">a <see cref="T:System.Boolean" /></param>
        <returns>a <see cref="T:System.Boolean" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipTaskbarHint">
      <MemberSignature Language="C#" Value="public bool SkipTaskbarHint { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters></Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="value">a <see cref="T:System.Boolean" /></param>
        <returns>a <see cref="T:System.Boolean" /></returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDefaultIconFromFile">
      <MemberSignature Language="C#" Value="public static bool SetDefaultIconFromFile (string filename);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Sets an icon to be used as fallback for windows that haven't had <see cref="P:Gtk.Window.IconList" /> called on them from a file on disk.</summary>
        <param name="filename">Location of icon file.</param>
        <returns><see langword="true" /> if setting the icon succeded.</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="Fullscreen">
      <MemberSignature Language="C#" Value="public void Fullscreen ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asks to place <paramref name="window" /> in the fullscreen state.</summary>
        <remarks>
	 <para>
	  Note that you shouldn't assume the window is definitely full screen afterward, because other entities (e.g. the user or window manager) could unfullscreen it again, and not all window managers honor requests to fullscreen windows. But normally the window will end up restored to its normal state. Just don't write code that crashes if not.
	 </para>
	 <para>
	  You can track the fullscreen state via the <see cref="F:Gtk.Widget.WindowStateEvent" /> event on <see cref="T:Gtk.Widget" />.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIconFromFile">
      <MemberSignature Language="C#" Value="public bool SetIconFromFile (string filename);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Sets the icon for <paramref name="window" />.</summary>
        <param name="filename">Location of icon file.</param>
        <returns><see langword="true" /> if setting the icon succeded.</returns>
        <remarks>
	 <para>
	  This method is equivalent to calling <see cref="M:Gtk.Window.ParseGeometry" /> with pixbuf created by loading the image from <paramref name="filename" />.
	 </para>
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unfullscreen">
      <MemberSignature Language="C#" Value="public void Unfullscreen ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asks to toggle off the fullscreen state for <paramref name="window" />.</summary>
        <remarks>
	 <para>
	  Note that you shouldn't assume the window is definitely not full screen afterward, because other entities (e.g. the user or window manager) could fullscreen it again, and not all window managers honor requests to unfullscreen windows. But normally the window will end up restored to its normal state. Just don't write code that crashes if not.
	 </para>
	 <para>
	  You can track the fullscreen state via the <see cref="F:Gtk.Widget.WindowStateEvent" /> event on <see cref="T:Gtk.Widget" />.
	 </para>
	</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
