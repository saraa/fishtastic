<Type Name="TextBuffer" FullName="Gtk.TextBuffer">
  <TypeSignature Language="C#" Value="public class TextBuffer : GLib.Object, IWrapper, IDisposable" Maintainer="duncan" />
  <AssemblyInfo>
    <AssemblyName>gtk-sharp</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
    <Attributes />
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the <link location="node:gtk-sharp/programming/threads">Gtk# Thread Programming</link> for details.</ThreadSafetyStatement>
  <Docs>
    <summary>
      This is a store for formatted text for display in a <see
      cref="T:Gtk.TextView" />.
    </summary>
    <remarks />
  </Docs>
  <Base>
    <BaseTypeName>GLib.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>GLib.IWrapper</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes />
  <Members>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears the contents in the current buffer</summary>
        <remarks>
          <para>
            This is a convenience call to <see
            cref="M:Gtk.TextBuffer.Clear(Gtk.TextIter,Gtk.TextIter)"
            />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteMarkByName">
      <MemberSignature Language="C#" Value="public void DeleteMarkByName (string name);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Deletes the mark named <see paramref="name" />; the mark must exist.</summary>
        <param name="name">the name of a mark in buffer</param>
        <remarks>
          <para>
            See <see cref="M:Gtk.TextBuffer.DeleteMark(Gtk.TextMark)"
            />  for more details.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public void GetBounds (out Gtk.TextIter start, out Gtk.TextIter end);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter&amp;" />
        <Parameter Name="end" Type="Gtk.TextIter&amp;" />
      </Parameters>
      <Docs>
        <summary>
          Retrieves the first and last iterators in the buffer, i.e. the entire buffer.
        </summary>
        <param name="start">
          A <see cref="T:Gtk.TextIter" /> object to store the location
          of the beginning of the buffer.
        </param>
        <param name="end">
          A <see cref="T:Gtk.TextIter" /> object to store the location
          of the end of the buffer.
        </param>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="RemoveTag">
      <MemberSignature Language="C#" Value="public void RemoveTag (Gtk.TextTag tag, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tag" Type="Gtk.TextTag" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <summary>
          Emits the "remove_tag" signal. 
        </summary>
        <param name="tag">the <see cref="T:Gtk.TextTag" /> to remove</param>
        <param name="start">the beginning of the range</param>
        <param name="end">the end of the range</param> 
        <remarks>
          <para>
            Fires the <see cref="E:Gtk.TextBuffer.RemoveTag" />
            event. The default handler for the signal removes all
            occurrences of tag from the given range. <see
            paramref="start" /> and <see paramref="end" />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAllTags">
      <MemberSignature Language="C#" Value="public void RemoveAllTags (Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <summary>
          Removes all tags in the range between <see paramref="start"
        /> and <see paramref="end" />.
        </summary>
        <param name="start">The beginning of the range</param>
        <param name="end">The end of the range</param>
        <remarks>
          <para>
            Removes all tags in the range between start and end. Be
            careful with this function; it could remove tags added in
            code unrelated to the code you're currently writing. That
            is, calling this method is probably a bad idea if you have
            two or more unrelated code sections that add tags.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMark">
      <MemberSignature Language="C#" Value="public Gtk.TextMark GetMark (string name);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextMark</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>
          Returns the mark named name in buffer buffer, or <see
          langword="null" /> if no such mark exists in the buffer.
        </summary>
        <param name="name">the name of a mark</param>
        <returns>
          Returns the mark named name in buffer buffer, or <see
          langword="null" /> if no such mark exists in the buffer.
        </returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="EndUserAction">
      <MemberSignature Language="C#" Value="public void EndUserAction ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertChildAnchor">
      <MemberSignature Language="C#" Value="public void InsertChildAnchor (Gtk.TextIter iter, Gtk.TextChildAnchor anchor);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter" />
        <Parameter Name="anchor" Type="Gtk.TextChildAnchor" />
      </Parameters>
      <Docs>
        <summary>Inserts a child widget anchor into the text buffer.</summary>
        <param name="iter">location to insert the anchor</param>
        <param name="anchor">a <see cref="T:Gtk.TextChildAnchor" />.</param>
        <remarks>
          <para>
            Inserts a child widget anchor into the text buffer at <see
            paramref="iter" />. The anchor will be counted as one
            character in character counts, and when obtaining the
            buffer contents as a string, will be represented by the
            Unicode "object replacement character" 0xFFFC. Note that
            the "slice" variants for obtaining portions of the buffer
            as a string include this character for pixbufs, but the
            "text" variants do not. e.g. see <see
            cref="M:Gtk.TextBuffer.GetSlice(Gtk.TextIter,Gtk.TextIter,System.Boolean)"
            /> and <see
            cref="M:Gtk.TextBuffer.GetText(Gtk.TextIter,Gtk.TextIter,System.Boolean)"
            />). Consider <see
            cref="M:Gtk.TextBuffer.CreateChildAnchor(Gtk.TextIter)" /> as a
            more convenient alternative to this function. The buffer
            will add a reference to the anchor, so you can unref it
            after insertion.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSelectionBounds">
      <MemberSignature Language="C#" Value="public bool GetSelectionBounds (out Gtk.TextIter start, out Gtk.TextIter end);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter&amp;" />
        <Parameter Name="end" Type="Gtk.TextIter&amp;" />
      </Parameters>
      <Docs>
        <summary>Returns <see langword="true" /> if some text is selected</summary>
        <param name="start">the location of the beginning of the selection</param>
        <param name="end">the location of the end of the selection</param>
        <returns>Returns <see langword="true" /> if the selection has nonzero length</returns>
        <remarks>
          <para>
            Returns <see langword="true" /> if some text is selected;
            and sets the bounds of the selection in <see
            paramref="start" /> and <see paramref="end" /> (if
            the selection has length 0, then start and end are filled
            in with the same value). <see paramref="start" /> and <see
            parmaref="end" /> will be in
            ascending order. If <see paramref="start" /> and <see
            paramref="end" /> are <see langword="null" />, then they are
            not filled in, but the return value still indicates
            whether text is selected.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginUserAction">
      <MemberSignature Language="C#" Value="public void BeginUserAction ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="PasteClipboard">
      <MemberSignature Language="C#" Value="public void PasteClipboard (Gtk.Clipboard clipboard, Gtk.TextIter override_location, bool default_editable);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipboard" Type="Gtk.Clipboard" />
        <Parameter Name="override_location" Type="Gtk.TextIter" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>
          Pastes the contents of a clipboard at the insertion point,
        or at <see paramref="override_location" />.
        </summary>
        <param name="clipboard">the <see cref="T:Gtk.Clipboard" /> to paste from</param>
        <param name="override_location">
          the location to insert pasted text, or <see langword="null"/> for at the cursor
        </param>
        <param name="default_editable">
          whether the buffer is editable by default
        </param>
        <remarks>
          Pastes the contents of a clipboard at the insertion point,
          or at <see paramref="override_location" />. (Note: pasting
          is asynchronous, that is, we'll ask for the paste data and
          return, and at some point later after the main loop runs,
          the paste data will be inserted.)
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveMark">
      <MemberSignature Language="C#" Value="public void MoveMark (Gtk.TextMark mark, Gtk.TextIter where);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mark" Type="Gtk.TextMark" />
        <Parameter Name="where" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <summary>Moves mark to the new location <see paremref="where" />.</summary>
        <param name="mark">a <see cref="T:Gtk.TextMark" />.</param>
        <param name="where">the new location for mark in buffer</param>
        <remarks>
          <para>
            Moves mark to the new location where. Fires the <see
            cref="E:Gtk.TextBuffer.MarkSet" /> event as notification of the move.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSlice">
      <MemberSignature Language="C#" Value="public string GetSlice (Gtk.TextIter start, Gtk.TextIter end, bool include_hidden_chars);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
        <Parameter Name="include_hidden_chars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>
          Returns the text from <see paramref="start" /> to <see
        paramref=",end" />.
        </summary>
        <param name="start">the start of a range</param>
        <param name="end">the end of the range</param>
        <param name="include_hidden_chars">whether to include invisible text</param>
        <returns>
          a string containing the text from <see paramref="start" />
          to <see paramref="end"/>
        </returns>
        <remarks>
          <para>
            Returns the text in the range from <see paramref="start"
            /> to <see paramref="end" />. Excludes undisplayed text
            (text marked with tags that set the invisibility
            attribute) if <see paramref="include_hidden_chars" /> is
            <see langword="false" />. The returned string includes a
            0xFFFC character whenever the buffer contains embedded
            images, so byte and character indexes into the returned
            string do correspond to byte and character indexes into
            the buffer. Contrast with <see
            cref="M:Gtk.TextBuffer.GetText(Gtk.TextIter,Gtk.TextIter,System.Boolean)"
            />. Note that 0xFFFC can occur in normal text as well, so
            it is not a reliable indicator that a pixbuf or widget is
            in the buffer.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateChildAnchor">
      <MemberSignature Language="C#" Value="public Gtk.TextChildAnchor CreateChildAnchor (Gtk.TextIter iter);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextChildAnchor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <summary>
          This is a convenience function which simply creates a child
          anchor with <see cref="C:Gtk.TextChildAnchor" /> and inserts it into
          the buffer with <see
          cref="M:Gtk.TextBuffer.InsertChildAnchor(Gtk.TextIter,Gtk.TextChildAnchor)"
          />.
        </summary>
        <param name="iter">the location in the buffer</param>
        <returns>the created child anchor</returns>
        <remarks>
          <para>
          This is a convenience function which simply creates a child
          anchor with <see cref="C:Gtk.TextChildAnchor" /> and inserts it into
          the buffer with <see
          cref="M:Gtk.TextBuffer.InsertChildAnchor(Gtk.TextIter,Gtk.TextChildAnchor)"
          />. The new anchor is owned by the buffer; no reference
          count is returned to the caller of <see
          cref="Gtk.TextBuffer.CreateChildAnchor(Gtk.TextIter)" />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyTag">
      <MemberSignature Language="C#" Value="public void ApplyTag (Gtk.TextTag tag, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tag" Type="Gtk.TextTag" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <summary>Fires the <see cref="E:Gtk.TextBuffer.ApplyTag" /> events on buffer.</summary>
        <param name="tag">a <see cref="Gtk.TextTag" /></param>
        <param name="start">the beginning of the range to be tagged</param>
        <param name="end">the end of the range to be tagged</param>
        <remarks>
          <para>
            The default handler for the signal applies tag to the
            given range. start and end do not have to be in order.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (Gtk.TextIter iter, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <summary>
          Copies text, tags, and pixbufs between <see paramref="start" />
          and <see paramref="end" /> and inserts the copy at <see paramref="iter" />.
        </summary>
        <param name="iter">a position in buffer</param>
        <param name="start">
          a position in the source <see cref="Gtk.TextBuffer" /> 
        </param>
        <param name="end">
          a position in the source <see cref="Gtk.TextBuffer" />           
        </param>
        <remarks>
          <para>
            Copies text, tags, and pixbufs between <see
            paramref="start" /> and <see paramref="end" /> (the
            order does not matter) and inserts the
            copy at <see paramref="iter" />. Used instead of simply getting/inserting
            text because it preserves images and tags. If <see
            paremref="start" /> and
            <see paramref="end" /> are in a different buffer from buffer, the two buffers
            must share the same tag table.
          </para>
          <para>
            This method is implemented with the <see
            cref="E:Gtk.TextBuffer.InsertText" /> and <see
            cref="E:Gtk.TextBuffer.ApplyTag" /> events.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveTagByName">
      <MemberSignature Language="C#" Value="public void RemoveTagByName (string name, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <summary>
          Calls <see cref="M:Gtk.TextTagTable.Lookup(System.String)"
          /> on the buffer's tag table to get a <see
          cref="T:Gtk.TextTag" />, then calls
          <see cref="Gtk.TextBuffer.RemoveTag((Gtk.TextTag,Gtk.TextIter,Gtk.TextIter)" />
        </summary>
        <param name="name">the name of the tag</param>
        <param name="start">the beginning of the buffer to be untagged</param>
        <param name="end">the end of the buffer to be untagged</param>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="DeleteSelection">
      <MemberSignature Language="C#" Value="public bool DeleteSelection (bool interactive, bool default_editable);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interactive" Type="System.Boolean" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>Deletes the currently-selected text</summary>
        <param name="interactive">whether the deletion is caused by user interaction</param>
        <param name="default_editable">whether the buffer is editable by default</param>
        <returns>
           whether there was a non-empty selection to delete
        </returns>
        <remarks>
          <para>
            Deletes the range between the "insert" and
            "selection_bound" marks, that is, the currently-selected
            text. If <see paramref="interactive" /> is <see
            langword="true" />, the editability of the selection will
            be considered (users can't delete uneditable text).
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteInteractive">
      <MemberSignature Language="C#" Value="public bool DeleteInteractive (Gtk.TextIter start_iter, Gtk.TextIter end_iter, bool default_editable);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start_iter" Type="Gtk.TextIter" />
        <Parameter Name="end_iter" Type="Gtk.TextIter" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>Deletes all editable text in the given range.</summary>
        <param name="start_iter">the beginning of range to delete</param>
        <param name="end_iter">the end of the range to delete</param>
        <param name="default_editable">whether the buffer is editable by default</param>
        <returns>whether some text was actually deleted</returns>
        <remarks>
          <para>
            Deletes all editable text in the given range. Calls <see
            cref="M:Gtk.TextBuffer.Delete(Gtk.TextIter,Gtk.TextIter)"
            /> for each editable sub-range of <see paramref="start" />
            and <see paramref="end" />. <see paramref="start" /> and
            <see paramref="end" /> are revalidated to point to the
            location of the last deleted range, or left untouched if
            no text was deleted.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSelectionClipboard">
      <MemberSignature Language="C#" Value="public void RemoveSelectionClipboard (Gtk.Clipboard clipboard);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipboard" Type="Gtk.Clipboard" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="clipboard">To be added: an object of type 'Gtk.Clipboard'</param>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <summary>
          Deletes text between <see paramref="start" /> and <see
        paramref="end" />.
        </summary>
        <param name="start">a position in the buffer</param>
        <param name="end">a position in the buffer</param>
        <remarks>
          <para>
            Deletes text between <see paramref="start" /> and <see
            paramref="end" />. The order of the two is not actually
            relevant, as they will be r reordered. This function
            actually fires off  the <see
            cref="E:Gtk.TextBuffer.DeleteRange" /> event, and the default
            handler of that signal deletes the text. Because the
            buffer is modified, all outstanding iterators become
            invalid after calling this function; however, the start
            and end will be re-initialized to point to the location
            where text was deleted.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PlaceCursor">
      <MemberSignature Language="C#" Value="public void PlaceCursor (Gtk.TextIter where);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="where" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <summary>Moves the "insert" and "selection_bound" marks simultaneously.</summary>
        <param name="where">where to put the cursor</param>
        <remarks>
          <para>
            This function moves the "insert" and "selection_bound"
            marks simultaneously. If you move them to the same place
            in two steps with <see
            cref="M:Gtk.TextBuffer.MoveMarkGtk.TextMark,Gtk.TextIter)"/>,
            you will temporarily select a region in between their old
            and new locations, which can be pretty inefficient since
            the temporarily-selected region will force stuff to be
            recalculated. This function moves them as a unit, which
            can be optimized.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSelectionClipboard">
      <MemberSignature Language="C#" Value="public void AddSelectionClipboard (Gtk.Clipboard clipboard);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipboard" Type="Gtk.Clipboard" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="clipboard">To be added: an object of type 'Gtk.Clipboard'</param>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteMark">
      <MemberSignature Language="C#" Value="public void DeleteMark (Gtk.TextMark mark);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mark" Type="Gtk.TextMark" />
      </Parameters>
      <Docs>
        <summary>Deletes mark, so that it's no longer located anywhere in the buffer.</summary>
        <param name="mark">
          a <see cref="T:Gtk.TextMark" /> in the buffer to be deleted.
        </param>
        <remarks>
          <para>
            Deletes mark, so that it's no longer located anywhere in
            the buffer.  There is no way to undelete a
            mark. <see cref="P:Gtk.TextMark.Deleted" /> will return
            <see langword="true" /> after
            this function has been called on a mark;
            <see cref="P:Gtk.TextMark.Deleted" /> indicates that a mark no
            longer belongs to a buffer. The <see
            cref="E:Gtk.TextBuffer.MarkDeleted" /> event will
            be fired as notification after the mark is deleted.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMark">
      <MemberSignature Language="C#" Value="public Gtk.TextMark CreateMark (string mark_name, Gtk.TextIter where, bool left_gravity);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextMark</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mark_name" Type="System.String" />
        <Parameter Name="where" Type="Gtk.TextIter" />
        <Parameter Name="left_gravity" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>Creates a mark at position <see paramref="where" />.</summary>
        <param name="mark_name">name for mark, or <see langword="null" />.</param>
        <param name="where">location to place mark</param>
        <param name="left_gravity">whether the mark has left gravity</param>
        <returns>a new <see cref="T:Gtk.TextMark" /> object</returns>
        <remarks>
          <para>
            Creates a mark at position where. If <see
            paramref="mark_name" /> is <see langword="null" />,
            the mark is anonymous; otherwise, the mark can be
            retrieved by name using <see
            cref="Gtk.TextBuffer.GetMark(System.String)" />. If a
            mark has left gravity, and text is inserted at the mark's
            current location, the mark will be moved to the left of
            the newly-inserted text. If the mark has right gravity
            (ie. <see paramref="left_gravity" /> = <see
            langword="false" />), the mark will end up on the right
            of newly-inserted text. The standard left-to-right cursor
            is a mark with right gravity (when you type, the cursor
            stays on the right side of the text you're typing).
          </para>
          <para>
            Fires the <see cref="E:Gtk.TextBuffer.MarkSet" /> event as
            notification of the mark's initial placement.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyClipboard">
      <MemberSignature Language="C#" Value="public void CopyClipboard (Gtk.Clipboard clipboard);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipboard" Type="Gtk.Clipboard" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="clipboard">To be added: an object of type 'Gtk.Clipboard'</param>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveMarkByName">
      <MemberSignature Language="C#" Value="public void MoveMarkByName (string name, Gtk.TextIter where);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="where" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <summary>
          Moves the mark named <see paramref="name" /> (which must
          exist) to location <see paramref="where" />.
        </summary>
        <param name="name">the name of the mark</param>
        <param name="where">the new location for mark</param>
        <remarks>
          <para>
            see <see cref="M:Gtk.TextBuffer.MoveMark(Gtk.TextMark,Gtk.TextIter)"/>
            for more details.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertRangeInteractive">
      <MemberSignature Language="C#" Value="public bool InsertRangeInteractive (Gtk.TextIter iter, Gtk.TextIter start, Gtk.TextIter end, bool default_editable);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>
          Same as <see
          cref="M:Gtk.TextBuffer.InsertRange(Gtk.TextIter,Gtk.TextIter,Gtk.TextIter)"
          />, but does nothing if the insertion point isn't editable.
        </summary>
        <param name="iter">a position in buffer</param>
        <param name="start">
          a position in the source <see cref="Gtk.TextBuffer" /> 
        </param>
        <param name="end">
          a position in the source <see cref="Gtk.TextBuffer" />           
        </param>
        <param name="default_editable">
          whether the text is editable at <see paramref="iter" /> if no tags enclosing
          iter affect editability
        </param>
        <returns>
          <see langword="true" /> if an insertion was possible at <see
          paramref="iter" />
        </returns>
        <remarks>
          <para>
            Same as <see
            cref="M:Gtk.TextBuffer.InsertRange(Gtk.TextIter,Gtk.TextIter,Gtk.TextIter)"
            />, but does nothing if the insertion point isn't
            editable.
          </para>
          <para>
            The <see paramref="default_editable" /> parameter
            indicates whether the text is editable at <see
            paramref="iter" /> if no tags
            enclosing iter affect editability. Typically the result of
            <see cref="P:Gtk.TextView.Editable" /> is appropriate here.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (Gtk.TextIter start, Gtk.TextIter end, bool include_hidden_chars);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
        <Parameter Name="include_hidden_chars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>Returns the text from a specified range</summary>
        <param name="start">the beginning of the specified range</param>
        <param name="end">the end of the specified range</param>
        <param name="include_hidden_chars">whether to include invisible text</param>
        <returns>a string containing the text from the specified range</returns>
        <remarks>
          <para>
            Returns the text in the range specified by <see
            paremref="start" /> and <see paremref="end" />. Excludes
            undisplayed text (text marked with tags that set the
            invisibility attribute) if <see
            paramref="include_hidden_chars" /> is <see
            langword="false" />. Does not include characters
            representing embedded images, so byte and character
            indexes into the returned string do not correspond to byte
            and character indexes into the buffer.
          </para>
          <para>
            Contrast this with <see
            cref="Gtk.TextBuffer.GetSlice(Gtk.TextIter,Gtk.TextIter,
            System.Boolean)" />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyTagByName">
      <MemberSignature Language="C#" Value="public void ApplyTagByName (string name, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <summary>
          Fires the <see cref="E:Gtk.TextBuffer.TagApplied" /> event on buffer. The default handler
          for the signal applies tag to the given range.
        </summary>
        <param name="name">the name of the tag</param>
        <param name="start">the location of the beginning of the range</param>
        <param name="end">the location of the end of the range</param>
        <remarks>
          <para>
            The order for <see paramref="start" /> and <see
            paramref="end" /> is not important.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertPixbuf">
      <MemberSignature Language="C#" Value="public void InsertPixbuf (Gtk.TextIter iter, Gdk.Pixbuf pixbuf);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter" />
        <Parameter Name="pixbuf" Type="Gdk.Pixbuf" />
      </Parameters>
      <Docs>
        <summary>
          Inserts an image into the text buffer at <see paramref="iter" />.
        </summary>
        <param name="iter">The location to insert the image</param>
        <param name="pixbuf">The image to be inserted</param>
        <remarks>
          <para>
            Inserts an image into the text buffer at <see
            paramref="iter" />. The image will be counted as one character in character counts, and
            when obtaining the buffer contents as a string, will be
            represented by the Unicode "object replacement character"
            0xFFFC. Note that the "slice" variants for obtaining
            portions of the buffer as a string include this character
            for pixbufs, but the "text" variants do not. e.g. see
            <see
            cref="M:Gtk.TextBuffer.GetSlice(Gtk.TextIter,Gtk.TextIter,System.Boolean)"
            /> and <see
            cref="M:Gtk.TextBuffer.GetText(Gtk.TextIter,Gtk.TextIter,System.Boolean)"
            />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CutClipboard">
      <MemberSignature Language="C#" Value="public void CutClipboard (Gtk.Clipboard clipboard, bool default_editable);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipboard" Type="Gtk.Clipboard" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="clipboard">To be added: an object of type 'Gtk.Clipboard'</param>
        <param name="default_editable">To be added: an object of type 'bool'</param>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="protected virtual void Finalize ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disposes the resources associated with the object.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBuffer (IntPtr raw);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="raw" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <summary>Internal constructor</summary>
        <param name="raw">Pointer to the C object.</param>
        <returns>An instance of TextBuffer, wrapping the C object.</returns>
        <remarks>
          <para>This is an internal constructor, and should not be used by user code.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBuffer (Gtk.TextTagTable table);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="table" Type="Gtk.TextTagTable" />
      </Parameters>
      <Docs>
        <summary>Creates a new text buffer.</summary>
        <param name="table">a tag table, or <see langword="null" /> to create a new one</param>
        <returns>a newly created TextBuffer</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TextBuffer ();" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <returns>To be added: an object of type 'Gtk.TextBuffer'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="GType">
      <MemberSignature Language="C#" Value="public static uint GType { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The GLib Type for Gtk.TextBuffer</summary>
        <returns>The GLib Type for the Gtk.TextBuffer class.</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>The complete contents of the buffer</summary>
        <param name="value">a string to be the contents of the buffer</param>
        <returns>The contents of the current buffer'</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="LineCount">
      <MemberSignature Language="C#" Value="public int LineCount { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtains the number of lines in the buffer.</summary>
        <returns>The number of lines in the buffer</returns>
        <remarks>
          <para>
            The results of this method is cache, so this is very fast.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIter">
      <MemberSignature Language="C#" Value="public Gtk.TextIter EndIter { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextIter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The end of the buffer</summary>
        <returns>The location of the end of the buffer</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="Modified">
      <MemberSignature Language="C#" Value="public bool Modified { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>Whether or not the buffer has been modified</summary>
        <param name="value">
          <see langword="true" /> if the buffer has
          been modified, <see langword="false" /> otherwise.
        </param>
        <returns>
          <see langword="true" /> if the buffer has
          been modified, <see langword="false" /> otherwise.
        </returns>
        <remarks>
          <para>
            Whenever the buffer is saved to disk, set this property to
            <see langword="false" />. When the buffer is modified, it
            will automatically toggled to <see langword="true" />.
          </para>
          <para>
            Whenever this property is changed, the <see
            cref="E.Gtk.TextBuffer.ModifiedChanged" /> event is fired.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TagTable">
      <MemberSignature Language="C#" Value="public Gtk.TextTagTable TagTable { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextTagTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The tag table of the current buffer</summary>
        <returns>The current <see cref="T:Gtk.TextTagTable" /> of the buffer</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="SelectionBound">
      <MemberSignature Language="C#" Value="public Gtk.TextMark SelectionBound { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextMark</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the mark that represents the selection bound.</summary>
        <returns>a <see cref="T:Gtk.TextMark" /></returns>
        <remarks>
          <para>
            Returns the mark that represents the selection
            bound. Equivalent to calling <see
            cref="Gtk.TextBuffer.GetMark(System.String)" /> to
            get the mark named "selection_bound", but very slightly
            more efficient, and involves less typing.
          </para>
          <para>
            The currently-selected text in buffer is the region
            between the "selection_bound" and "insert" marks. If
            "selection_bound" and "insert" are in the same place, then
            there is no current selection. <see
            cref="M:Gtk.TextBuffer.GetSelectionBounds(Gtk.TextIter,Gtk.TextIter)"
            /> is another convenient function for handling the
            selection, if you just want to know whether there's a
            selection and what its bounds are.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertMark">
      <MemberSignature Language="C#" Value="public Gtk.TextMark InsertMark { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextMark</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the mark that represents the cursor (insertion point).</summary>
        <returns>The mark of the insert point.</returns>
        <remarks>
          <para>
            This is equivelant to calling <see
            cref="M:Gtk.TextBuffer.GetMark(System.String)" /> for the
            mark named "insert". 
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CharCount">
      <MemberSignature Language="C#" Value="public int CharCount { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The number of characters in the buffer</summary>
        <returns>The number of characters in the buffer</returns>
        <remarks>
          <para>The result of this method is cached, so it is very fast.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartIter">
      <MemberSignature Language="C#" Value="public Gtk.TextIter StartIter { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextIter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The location of the beginning of the buffer</summary>
        <returns>The location of the beginning of the buffer</returns>
        <remarks>
          <para>
            This is the equivelant to calling <see
            cref="M:Gtk.TextBuffer.GetIterAtOffset(System.Int32)" /> to get the iter at character offset 0.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserActionEnded">
      <MemberSignature Language="C#" Value="public event EventHandler UserActionEnded;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="TagRemoved">
      <MemberSignature Language="C#" Value="public event GtkSharp.TagRemovedHandler TagRemoved;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserActionBegun">
      <MemberSignature Language="C#" Value="public event EventHandler UserActionBegun;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkSet">
      <MemberSignature Language="C#" Value="public event GtkSharp.MarkSetHandler MarkSet;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="TagApplied">
      <MemberSignature Language="C#" Value="public event GtkSharp.TagAppliedHandler TagApplied;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildAnchorInserted">
      <MemberSignature Language="C#" Value="public event GtkSharp.ChildAnchorInsertedHandler ChildAnchorInserted;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkDeleted">
      <MemberSignature Language="C#" Value="public event GtkSharp.MarkDeletedHandler MarkDeleted;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteRange">
      <MemberSignature Language="C#" Value="public event GtkSharp.DeleteRangeHandler DeleteRange;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="PixbufInserted">
      <MemberSignature Language="C#" Value="public event GtkSharp.PixbufInsertedHandler PixbufInserted;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertText">
      <MemberSignature Language="C#" Value="public event GtkSharp.InsertTextHandler InsertText;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifiedChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ModifiedChanged;" />
      <MemberType>Event</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIterAtOffset">
      <MemberSignature Language="C#" Value="public Gtk.TextIter GetIterAtOffset (int char_offset);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextIter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="char_offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Returns the location at a particular character offset</summary>
        <param name="char_offset">The requested character offset</param>
        <returns>The location at <see paramref="char_offset" /></returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="InsertAtCursor">
      <MemberSignature Language="C#" Value="public void InsertAtCursor (string text);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Insert text into the current cursor position</summary>
        <param name="text">The text to be inserted</param>
        <remarks>
          <para>
            The <see cref="E:Gtk.TextBuffer.InsertText" /> event is
            fired when a call to this method is made.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (Gtk.TextIter iter, string text);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Insert text at a specific point</summary>
        <param name="iter">
          The location for <see paramref="text" /> to be
          inserted
        </param>
        <param name="text">The text to be inserted</param>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="InsertInteractiveAtCursor">
      <MemberSignature Language="C#" Value="public bool InsertInteractiveAtCursor (string text, bool default_editable);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>Insert text at cursor position if the location is editable</summary>
        <param name="text">The text to be inserted</param>
        <param name="default_editable">The default editability of the buffer</param>
        <returns>Whether or not <see paramref="text" /> was inserted</returns> 
        <remarks>
          See <see
          cref="M:Gtk.TextBuffer.InsertInteractive(Gtk.TextIter,System.String,System.Boolean)"
          /> for more details.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertInteractive">
      <MemberSignature Language="C#" Value="public bool InsertInteractive (Gtk.TextIter iter, string text, bool default_editable);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <summary>
          Insert text if the cursor is at an editable point in
          the buffer
        </summary>
        <param name="iter">a location in the buffer</param>
        <param name="text">the text to be inserted</param>
        <param name="default_editable">the default editability of buffer</param>
        <returns>whether text was actually inserted</returns>
        <remarks>
          <para>
            Similar to <see
            cref="M:Gtk.TextBuffer.Insert(Gtk.TextIter,System.String)"
            />, but the insertion will not occur if <see
            paramref="iter" /> is at a non-editable location in the
            buffer. Usually you want to prevent insertions at
            ineditable locations if the insertion results from a user
            action (is interactive).
          </para>
          <para>
            <see paramref="default_editable" /> indicates the editability of text that
            doesn't have a tag affecting editability applied to
            it. Typically the result of <see
            cref="P:Gtk.TextView.Editable" />
            is appropriate here.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetText">
      <MemberSignature Language="C#" Value="public void SetText (string text);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Set the contents of the buffer</summary>
        <param name="text">The new contents of the buffer</param>
        <remarks>
          <para>
            This is equivelant to using the setter of the
            <see cref="P:Gtk.TextBuffer.Text" /> property.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TextBuffer (GLib.Type gtype);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="gtype" Type="GLib.Type" />
      </Parameters>
      <Docs>
        <summary>Internal constructor</summary>
        <param name="gtype">GLib type for the type</param>
        <returns>Creates a new instance of TextBuffer, using the GLib-provided type</returns>
        <remarks>
          <para>This is a constructor used by derivative types of <see cref="T:Gtk.TextBuffer" /> that would have their own GLib type assigned to it.  This is not typically used by C# code.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIterAtOffset">
      <MemberSignature Language="C#" Value="public void GetIterAtOffset (out Gtk.TextIter iter, int char_offset);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" />
        <Parameter Name="char_offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Gets the location at a specific character offset</summary>
        <param name="iter">The location of <see paramref="char_offset" /></param>
        <param name="char_offset">
          The number of characters from the beginning of the buffer
        </param>
        <remarks>
          <para>
            if <see paramref="char_offset" /> is -1, or greater than
            the number of characters in the buffer, <see
            paramref="iter"/> will be initialized to the end iterator.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIterAtLineIndex">
      <MemberSignature Language="C#" Value="public void GetIterAtLineIndex (out Gtk.TextIter iter, int line_number, int byte_index);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" />
        <Parameter Name="line_number" Type="System.Int32" />
        <Parameter Name="byte_index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="iter">
          The location as specified by <see paramref="line_number" />
        and <see paramref="byte_index" />
        </param>
        <param name="line_number">
          A line number for the current buffer, counting from 0.
        </param>
        <param name="byte_index">
          the byte index from start of line
        </param>
        <remarks>
          <para>
            <see paramref="byte_index" /> must be the start of a
            UTF-8 character, and must not be beyond the end of the
            line. Note bytes, not characters; UTF-8 may encode one
            character as multiple bytes.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIterAtChildAnchor">
      <MemberSignature Language="C#" Value="public void GetIterAtChildAnchor (out Gtk.TextIter iter, Gtk.TextChildAnchor anchor);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" />
        <Parameter Name="anchor" Type="Gtk.TextChildAnchor" />
      </Parameters>
      <Docs>
        <summary>Gets the location of the specific anchor</summary>
        <param name="iter">the location at <see paramref="anchor" /></param>
        <param name="anchor">
          a <see cref="T:Gtk.TextChildAnchor" /> at the current buffer.
        </param>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GetIterAtMark">
      <MemberSignature Language="C#" Value="public void GetIterAtMark (out Gtk.TextIter iter, Gtk.TextMark mark);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" />
        <Parameter Name="mark" Type="Gtk.TextMark" />
      </Parameters>
      <Docs>
        <summary>Gets the location of the specified mark</summary>
        <param name="iter">The location of <see paramref="mark" />.</param>
        <param name="mark">The specified mark</param>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GetIterAtLine">
      <MemberSignature Language="C#" Value="public void GetIterAtLine (out Gtk.TextIter iter, int line_number);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" />
        <Parameter Name="line_number" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Gets the location of a particular line</summary>
        <param name="iter">
          The location at the beginning fo the line as specified by
          <see paramref="line_number" />
        </param>
        <param name="line_number">The specified line number</param>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GetIterAtLineOffset">
      <MemberSignature Language="C#" Value="public void GetIterAtLineOffset (out Gtk.TextIter iter, int line_number, int char_offset);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" />
        <Parameter Name="line_number" Type="System.Int32" />
        <Parameter Name="char_offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Gets the location of a specific point</summary>
        <param name="iter">
          The location at the location specified by <see
          paramref="line_number" /> and <see paramref="char_offset" />.
        </param>
        <param name="line_number">To be added: an object of type 'int'</param>
        <param name="char_offset">To be added: an object of type 'int'</param>
        <remarks />
      </Docs>
    </Member>
  </Members>
</Type>