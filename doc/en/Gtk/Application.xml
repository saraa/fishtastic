<Type Name="Application" FullName="Gtk.Application">
  <TypeSignature Language="C#" Value="public class Application" Maintainer="auto" />
  <AssemblyInfo>
    <AssemblyName>gtk-sharp</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
    <Attributes />
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the <link location="node:gtk-sharp/programming/threads">Gtk# Thread Programming</link> for details.</ThreadSafetyStatement>
  <Docs>
    <summary>Application class</summary>
    <remarks>
      <para>
	Provides the initialization and event loop iteration related
	methods for the GTK widget library.  Since GTK+ is an event 
	driven toolkit, Applications register callbacks against various
	events to handle user input. These callbacks are invoked from
	the main event loop when events are detected.
      </para>
    </remarks>
  </Docs>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes />
  <Members>
    <Member MemberName="Quit">
      <MemberSignature Language="C#" Value="public static void Quit ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quits the current main loop</summary>
        <remarks>
          <para>
	    Makes the innermost invocation of the main loop return when it regains control.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RunIteration">
      <MemberSignature Language="C#" Value="public static void RunIteration ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary />
        <remarks>
          <para>
	    Runs a single iteration of the mainloop. If no events are
	    waiting to be processed GTK+ will block until the next
	    event is noticed.  If you don't want to block look at <see cref="M:Gtk.Application.RunIteration(bool)" /> or check if
	    any events are pending with <see cref="M:Gtk.Application.EventsPending()" /> first.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RunIteration">
      <MemberSignature Language="C#" Value="public static bool RunIteration (bool block);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="block" Type="System.Boolean;" />
      </Parameters>
      <Docs>
        <summary />
        <param name="block">A boolean value, whether the iteration should block or not</param>
        <remarks>
          <para>
	    Runs a single iteration of the mainloop. If <paramref name="block" /> is true, then if no events are
	    waiting to be processed GTK+ will block until the next
	    event is noticed;  If <paramref name="block" /> is false,
	    then it if no events are waiting to be processed Gtk+ the
	    routine will return immediately.  
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EventsPending">
      <MemberSignature Language="C#" Value="public static bool EventsPending ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Whether there are events on the queue</summary>
        <returns>true if events are available to be processed, false otherwise</returns>
        <remarks>
          <para>
	    Checks if any events are pending. This can be used to
	    update the GUI and invoke timeouts etc. while doing some
	    time intensive computation.
	  </para>
          <example>
            <code lang="C#">
	      void LongComputation ()
	      {
	           while (!done){
	               ComputationChunk ();

	               // Flush pending events to keep the GUI reponsive
	               while (Application.EventsPending ())
	                  Application.RunIteration ();
	           }
	      }
	    </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Runs the main loop</summary>
        <remarks>
          <para>
	    Runs the main loop until <see cref="M:Gtk.Application.Quit()" /> is called. You can nest
	    calls to <see cref="Gtk.Application.Run()" />.  In that
	    case <see cref="M:Gtk.Application.Quit()" /> will make the
	    innermost invocation of the main loop return.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init" Deprecated="true">
      <MemberSignature Language="C#" Value="public static void Init (ref string [] args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]&amp;" />
      </Parameters>
      <Docs>
        <summary>Initializes GTK+ for operation.</summary>
        <param name="args">The arguments to pass to the toolkit</param>
        <remarks>
          <para>
	    Call this function before using any other GTK+ functions
	    in your GUI applications. It will initialize everything
	    needed to operate the toolkit.
	  </para>
          <para>
	    This function will terminate your program if it was unable
	    to initialize the GUI for some reason. If you want your
	    program to fall back to a textual interface you want to
	    call <see cref="M:Gtk.Application.InitCheck()" /> instead.
	  </para>
          <para>
	    The args values will be modified after Gtk has removed the
	    command line options that it handles itself.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitCheck" Deprecated="true">
      <MemberSignature Language="C#" Value="public static bool InitCheck (ref string [] args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]&amp;" />
      </Parameters>
      <Docs>
        <summary>Initializes GTK+ for operation, probes window system.</summary>
        <returns>true if the toolkit was initialized, false if the
        windowing system can not be initilized.</returns>
        <param name="args">The arguments to pass to the toolkit</param>
        <remarks>
          <para>
	    You use this call to initialize GTK+ for your GUI
	    applications.  This method will allow your application to
	    be both GUI/text.  A true return value means that the
	    toolkit was initialized, a false value means that the
	    toolkit could not be initialized.  If you do not want to
	    do dual GUI/text applications, you can use <see cref="M:Gtk.Application.Init()" /> instead. 
	  </para>
          <para>
	    This function will terminate your program if it was unable
	    to initialize the GUI for some reason. If you want your
	    program to fall back to a textual interface you want to
	    call <see cref="M:Gtk.Application.InitCheck()" /> instead.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor" Deprecated="true">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <returns>To be added: an object of type 'Gtk.Application'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public static void Init ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initializes GTK+ for operation.</summary>
        <remarks>
          <para>
	    Call this function before using any other GTK+ functions
	    in your GUI applications. It will initialize everything
	    needed to operate the toolkit.
	  </para>
          <para>
	    This function will terminate your program if it was unable
	    to initialize the GUI for some reason. If you want your
	    program to fall back to a textual interface you want to
	    call <see cref="M:Gtk.Application.InitCheck()" /> instead.
	  </para>
          <para>
	    If you want to pass arguments from the command line use
	    the <see cref="T:Gtk.Application.Init(ref string[])" />
	    method instead. 
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentEvent">
      <MemberSignature Language="C#" Value="public object CurrentEvent { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added</summary>
        <returns>To be added: an object of type 'object'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitCheck">
      <MemberSignature Language="C#" Value="public static bool InitCheck (ref String[] args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]&amp;" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="args">To be added: an object of type 'String[]&amp;'</param>
        <returns>To be added: an object of type 'bool'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public static void Init (ref String[] args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]&amp;" />
      </Parameters>
      <Docs>
        <summary>To be added</summary>
        <param name="args">To be added: an object of type 'String[]&amp;'</param>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
  </Members>
</Type>