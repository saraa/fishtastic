<Type Name="Layout" FullName="Pango.Layout">
  <TypeSignature Language="C#" Value="public class Layout : GLib.Object, IWrapper, IDisposable" Maintainer="auto" />
  <AssemblyInfo>
    <AssemblyName>pango-sharp</AssemblyName>
    <AssemblyPublicKey>
    </AssemblyPublicKey>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
    <AssemblyCulture>neutral</AssemblyCulture>
    <Attributes />
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the <link location="node:gtk-sharp/programming/threads">Gtk# Thread Programming</link> for details.</ThreadSafetyStatement>
  <Docs>
    <summary>High-level driver for formatting entire paragraphs of text at once.</summary>
    <remarks>
      <para>While complete access to the layout capabilities of Pango is provided using the detailed interfaces for itemization and shaping, using that functionality directly involves writing a fairly large amount of code. The objects and functions in <see cref="T:Pango.Layout" /> provide a high-level driver for formatting entire paragraphs of text at once.</para>
      <para>The <see cref="T:Pango.Layout" /> represents and entire paragraph of text. It is initialized with a <see cref="T:Pango.Context" />, UTF-8 string and set of attributes for that string. Once that is done, the set of formatted lines can be extracted from the object, the layout can be rendered, and conversion between logical character positions within the layout's text, and the physical position of the resulting glyphs can be made.</para>
      <para>There are also a number of parameters to adjust the formatting of a <see cref="T:Pango.Layout" />. It is possible, as well, to ignore the 2-D setup, and simply treat the results of a <see cref="T:Pango.Layout" /> as a list of lines.</para>
    </remarks>
    <example>
      <code lang="C#">
using System;
using Gtk;
using Pango;
 
class LayoutSample : DrawingArea
{
        Pango.Layout layout;
 
        static void Main ()
        {
                Application.Init ();
                new LayoutSample ();
                Application.Run ();
        }
 
        LayoutSample ()
        {
                Window win = new Window ("Layout sample");
                win.SetDefaultSize (400, 300);
                win.DeleteEvent += OnWinDelete;
                this.Realized += OnRealized;
                this.ExposeEvent += OnExposed;
 
                win.Add (this);
                win.ShowAll ();
        }
 
        void OnExposed (object o, ExposeEventArgs args)
        {
                this.GdkWindow.DrawLayout (this.Style.TextGC (StateType.Normal), 100, 150, layout);
        }
 
        void OnRealized (object o, EventArgs args)
        {
                layout = new Pango.Layout (this.PangoContext);
                layout.Wrap = Pango.WrapMode.Word;
                layout.FontDescription = FontDescription.FromString ("Tahoma 16");
                layout.SetMarkup ("Hello Pango.Layout");
        }
 
        void OnWinDelete (object o, DeleteEventArgs args)
        {
                Application.Quit ();
        }
}
	  </code>
    </example>
  </Docs>
  <Base>
    <BaseTypeName>GLib.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>GLib.IWrapper</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes />
  <Members>
    <Member MemberName="SetMarkup">
      <MemberSignature Language="C#" Value="public void SetMarkup (string markup);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="markup" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Sets the layout text and attribute list from marked-up text (see markup format).</summary>
        <param name="markup">marked-up text</param>
        <remarks>Replaces the current text and attribute list.
</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetText">
      <MemberSignature Language="C#" Value="public void SetText (string text);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <summary>Set the text of the layout.</summary>
        <param name="text">To be added: an object of type 'string'</param>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLine">
      <MemberSignature Language="C#" Value="public Pango.LayoutLine GetLine (int line);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Pango.LayoutLine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="line" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Retrieves a particular line.</summary>
        <param name="line">the index of a line.</param>
        <returns>the requested <see cref="T:Pango.LayoutLine" />, or null if the index is out of range.</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSize">
      <MemberSignature Language="C#" Value="public void GetSize (out int width, out int height);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="height" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <summary>Determines the logical width and height of a <see cref="T:Pango.Layout" /> in Pango units (device units divided by <see cref="F:Pango.Scale.PangoScale" />).</summary>
        <param name="width"> location to store the logical width, or <see langword="null" /></param>
        <param name="height"> location to store the logical height, or <see langword="null" /></param>
        <remarks>This is simply a convenience function around <see cref="M:Pango.Layout.GetExtents()" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public Pango.Layout Copy ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Pango.Layout</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copies an existing layout into a new one.</summary>
        <returns>an object of type <see cref="T:Pango.Layout" /></returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="ContextChanged">
      <MemberSignature Language="C#" Value="public void ContextChanged ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Forces recomputation of any state in the <see cref="T:Pango.Layout" /> that might depend on the layout's context.</summary>
        <remarks>This function should be called if you make changes to the context subsequent to creating the layout.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPixelSize">
      <MemberSignature Language="C#" Value="public void GetPixelSize (out int width, out int height);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="height" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <summary>Determine the logical width and height of a <see cref="T:Pango.Layout" /> in device units.</summary>
        <param name="width">To be added: an object of type 'int&amp;'</param>
        <param name="height">To be added: an object of type 'int&amp;'</param>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="protected override void Finalize ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disposes the resources associated with the object.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Layout (IntPtr raw);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="raw" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <summary>Internal constructor</summary>
        <param name="raw">Pointer to the C object.</param>
        <returns>An instance of Layout, wrapping the C object.</returns>
        <remarks>
          <para>This is an internal constructor, and should not be used by user code.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Layout (Pango.Context context);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="context" Type="Pango.Context" />
      </Parameters>
      <Docs>
        <summary>Create a new PangoLayout object with attributes initialized to default values for a particular <see cref="T:Pango.Context" />.</summary>
        <param name="context">a <see cref="T:Pango.Context" />.</param>
        <returns>a new <see cref="T:Pango.Layout" />.</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineCount">
      <MemberSignature Language="C#" Value="public int LineCount { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieves the count of lines for the layout.</summary>
        <returns> the line count</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="Indent">
      <MemberSignature Language="C#" Value="public int Indent { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>Return the lines of the layout as a list.</summary>
        <param name="value">To be added: an object of type 'int'</param>
        <returns>To be added: an object of type 'int'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Alignment">
      <MemberSignature Language="C#" Value="public Pango.Alignment Alignment { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Pango.Alignment</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>The amount by which the first line should be shorter than the rest of the lines.</summary>
        <param name="value">the amount by which to indent.</param>
        <returns>To be added: an object of type 'Pango.Alignment'</returns>
        <remarks>The value be negative, in which case the subsequent lines will be shorter than the first line. (However, in either case, the entire width of the layout will be given by the value.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tabs">
      <MemberSignature Language="C#" Value="public Pango.TabArray Tabs { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Pango.TabArray</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>The alignment for the layout.</summary>
        <param name="value">The new alignment.</param>
        <returns>The current alignment.</returns>
        <remarks>Specifies how partial lines are positioned within the horizontal space available.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SingleParagraphMode">
      <MemberSignature Language="C#" Value="public bool SingleParagraphMode { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>The tabs to use for the layout.</summary>
        <param name="value">the tabs to use for the layout.</param>
        <returns>the current <see cref="T:Pango.TabArray" /> used by this layout. If no <see cref="T:Pango.TabArray" /> has been set, then the default tabs are in use and null is returned.</returns>
        <remarks>
          <para>By default, tabs are every 8 spaces.</para>
          <para>Setting new tabs overrides the default tabs. If Tabs is set to null, the default tabs are reinstated.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public Pango.Context Context { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Pango.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether or not to treat newlines and similar characters as paragraph separators.</summary>
        <returns>To be added: an object of type 'Pango.Context'</returns>
        <remarks>
          <para>If set to true, do not treat newlines and similar characters as paragraph separators; instead, keep all text in a single paragraph, and display a glyph for paragraph separator characters.</para>
          <para>Used when you want to allow editing of newlines on a single text line.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Iter">
      <MemberSignature Language="C#" Value="public Pango.LayoutIter Iter { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Pango.LayoutIter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>the <see cref="T:Pango.Context" /> used for this layout.</summary>
        <returns>To be added: an object of type 'Pango.LayoutIter'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public Pango.AttrList Attributes { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Pango.AttrList</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>An iterator to iterate over the visual extents of the layout.</summary>
        <param name="value">To be added: an object of type 'Pango.AttrList'</param>
        <returns>a new <see cref="T:Pango.LayoutIter" />.</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Spacing">
      <MemberSignature Language="C#" Value="public int Spacing { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>the amount of spacing between the lines of the layout.</summary>
        <param name="value"> the amount of spacing (in <see cref="T:Pango.GlyphUnit" />)</param>
        <returns>the amount of spacing (in <see cref="T:Pango.GlyphUnit" />)            </returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="Justify">
      <MemberSignature Language="C#" Value="public bool Justify { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>The amount of spacing between the lines of the layout.</summary>
        <param name="value">the amount of spacing.</param>
        <returns>To be added: an object of type 'bool'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public int Width { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>Sets whether or not each complete line should be stretched to fill the entire width of the layout.</summary>
        <param name="value">whether the lines in the layout should be justified.</param>
        <returns>To be added: an object of type 'int'</returns>
        <remarks>This stretching is typically done by adding whitespace, but for some scripts (such as Arabic), the justification is done by extending the characters.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the width to which the lines of the Layout should be wrapped.</summary>
        <returns>To be added: an object of type 'string'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="Wrap">
      <MemberSignature Language="C#" Value="public Pango.WrapMode Wrap { set; get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Pango.WrapMode</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>Gets or sets the wrap mode</summary>
        <param name="value"> the new wrap mode</param>
        <returns> Active wrap mode.</returns>
        <remarks>The wrap mode only has an effect if a width is set on the layout using <see cref="P:Pango.Layout.Width" />. To turn off wrapping, set the width to -1.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontDescription">
      <MemberSignature Language="C#" Value="public Pango.FontDescription FontDescription { set; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Pango.FontDescription</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>Sets the <see cref="T:Pango.WrapMode" />.</summary>
        <param name="value">To be added: an object of type 'Pango.FontDescription'</param>
        <returns>To be added: an object of type 'Pango.FontDescription'</returns>
        <remarks>The wrap style only has an effect if a width is set on the layout. To turn off wrapping, set the width to -1.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveCursorVisually">
      <MemberSignature Language="C#" Value="public void MoveCursorVisually (bool strong, int old_index, int old_trailing, int direction, out int new_index, out int new_trailing);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strong" Type="System.Boolean" />
        <Parameter Name="old_index" Type="System.Int32" />
        <Parameter Name="old_trailing" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Int32" />
        <Parameter Name="new_index" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="new_trailing" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <summary>Computes a new cursor position from an old position and a count of positions to move visually.</summary>
        <param name="strong"> whether the moving cursor is the strong cursor or the weak cursor. The strong cursor is the cursor corresponding to text insertion in the base direction for the layout.</param>
        <param name="old_index">	 the byte index of the grapheme for the old index </param>
        <param name="old_trailing"> if 0, the cursor was at the trailing edge of the grapheme indicated by old_index, if &gt; 0, the cursor was at the leading edge.</param>
        <param name="direction">	 direction to move cursor. A negative value indicates motion to the left.</param>
        <param name="new_index"> location to store the new cursor byte index. A value of -1 indicates that the cursor has been moved off the beginning of the layout. A value of G_MAXINT indicates that the cursor has been moved off the end of the layout.</param>
        <param name="new_trailing"> number of characters to move forward from the location returned for <paramref name="new_index" /> to get the position where the cursor should be displayed. This allows distinguishing the position at the beginning of one line from the position at the end of the preceding line. <paramref name="new_index" /> is always on the line where the cursor should be displayed.</param>
        <remarks>
          <para>If <paramref name="count" /> is positive, then the new strong cursor position will be one position to the right of the old cursor position. If <paramref name="count" /> is negative then the new strong cursor position will be one position to the left of the old cursor position.
</para>
          <para>In the presence of bi-directional text, the correspondence between logical and visual order will depend on the direction of the current run, and there may be jumps when the cursor is moved off of the end of a run.
</para>
          <para>Motion here is in cursor positions, not in characters, so a single call may move the cursor over multiple characters when multiple characters combine to form a single grapheme.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XyToIndex">
      <MemberSignature Language="C#" Value="public bool XyToIndex (int x, int y, out int index_, out int trailing);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="index_" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="trailing" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <summary>Computes a new cursor position from an old position and a count of positions to move visually.</summary>
        <param name="strong">whether the moving cursor is the strong cursor or the weak cursor. The strong cursor is the cursor corresponding to text insertion in the base direction for the layout.</param>
        <param name="old_index">the byte index of the grapheme for the old index.</param>
        <param name="old_trailing">if 0, the cursor was at the trailing edge of the grapheme indicated by old_index, if &gt; 0, the cursor was at the leading edge.</param>
        <param name="direction">direction to move cursor. A negative value indicates motion to the left.</param>
        <returns>a <see cref="T:System.Boolean" /></returns>
        <remarks>
          <para>If count is positive, then the new strong cursor position will be one position to the right of the old cursor position. If count is position then the new strong cursor position will be one position to the left of the old cursor position.</para>
          <para>In the presence of bidirection text, the correspondence between logical and visual order will depend on the direction of the current run, and there may be jumps when the cursor is moved off of the end of a run.</para>
          <para>Motion here is in cursor positions, not in characters, so a single call to MoveCursorVisually() may move the cursor over multiple characters when multiple characters combine to form a single grapheme.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GType">
      <MemberSignature Language="C#" Value="public static GLib.GType GType { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>GLib.GType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>GType Property.</summary>
        <returns>a <see cref="T:GLib.GType" /></returns>
        <remarks>Returns the native <see cref="T:GLib.GType" /> value for <see cref="T:Pango.Layout" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Layout (GLib.GType gtype);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="gtype" Type="GLib.GType" />
      </Parameters>
      <Docs>
        <summary>Convert from X and Y position within a layout to the byte index to the character at that logical position.</summary>
        <param name="x">the X offset from the left edge of the layout.</param>
        <returns>true if the coordinates were inside text.</returns>
        <remarks>If the position is not inside the layout, the closest position is chosen (the x/y position will be clamped inside the layout). If a closest position is chosen, then the function returns false; on an exact hit, it returns true.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lines">
      <MemberSignature Language="C#" Value="public Pango.LayoutLine [] Lines { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Pango.LayoutLine[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>The count of lines for the layout.</summary>
        <returns>The count of lines for the layout.</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GetExtents">
      <MemberSignature Language="C#" Value="public void GetExtents (out Pango.Rectangle ink_rect, out Pango.Rectangle logical_rect);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ink_rect" Type="Pango.Rectangle&amp;" RefType="out" />
        <Parameter Name="logical_rect" Type="Pango.Rectangle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <summary>Computes the logical and ink extents</summary>
        <param name="ink_rect"> rectangle used to store the extents of the layout as drawn or <see langword="null" /> to indicate that the result is not needed.</param>
        <param name="logical_rect"> rectangle used to store the logical extents of the layout or <see langword="null" /> to indicate that the result is not needed.</param>
        <remarks>Logical extents are usually what you want for positioning things. The extents are given in layout coordinates; layout coordinates begin at the top left corner of the layout.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexToPos">
      <MemberSignature Language="C#" Value="public Pango.Rectangle IndexToPos (int index_);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Pango.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index_" Type="System.Int32" />
      </Parameters>
      <Docs>
        <summary>Obtains the graphical position of an offset in the <see cref="T:Pango.Layout" />.</summary>
        <param name="index_">a byte offset within the text buffer.</param>
        <returns>a <see cref="T:Pango.Rectangle" /> representing the position of the grapheme associated with <paramref name="index_" />.</returns>
        <remarks>
          <para>
The X coordinate of the resulting <see cref="T:Pango.Rectangle" /> represents the leading edge of the grapheme.  If the direction of the grapheme is right to left, the Width value will be negative.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLogAttrs">
      <MemberSignature Language="C#" Value="public int GetLogAttrs (Pango.LogAttr attrs);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attrs" Type="Pango.LogAttr" />
      </Parameters>
      <Docs>
        <summary>Retrieves an array of logical attributes for each character in the layout.</summary>
        <param name="attrs">a <see cref="T:Pango.LogAttr" /></param>
        <returns>a <see cref="T:System.Int32" /></returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GetPixelExtents">
      <MemberSignature Language="C#" Value="public void GetPixelExtents (out Pango.Rectangle ink_rect, out Pango.Rectangle logical_rect);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ink_rect" Type="Pango.Rectangle&amp;" RefType="out" />
        <Parameter Name="logical_rect" Type="Pango.Rectangle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <summary>Compute the logical and ink extents of layout.</summary>
        <param name="ink_rect">Rectangle used to store the extents of the layout as drawn.</param>
        <param name="logical_rect">Rectangle used to store the logical extents of the layout.</param>
        <remarks>
          <para>
	  Logical extents are usually what you want for positioning things. The extents are given in layout coordinates; layout coordinates begin at the top left corner of the layout.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCursorPos">
      <MemberSignature Language="C#" Value="public void GetCursorPos (int index_, out Pango.Rectangle strong_pos, out Pango.Rectangle weak_pos);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index_" Type="System.Int32" />
        <Parameter Name="strong_pos" Type="Pango.Rectangle&amp;" RefType="out" />
        <Parameter Name="weak_pos" Type="Pango.Rectangle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <summary>Given an index within a layout, determines the positions that of the strong and weak cursors if the insertion point is at that index.</summary>
        <param name="index_"> the byte index of the cursor</param>
        <param name="strong_pos"> location to store the strong cursor position (may be <see langword="null" />)</param>
        <param name="weak_pos"> location to store the weak cursor position (may be <see langword="null" />)</param>
        <remarks>The position of each cursor is stored as a zero-width rectangle. The strong cursor location is the location where characters of the directionality equal to the base direction of the layout are inserted. The weak cursor location is the location where characters of the directionality opposite to the base direction of the layout are inserted.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>