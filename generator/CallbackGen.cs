// GtkSharp.Generation.CallbackGen.cs - The Callback Generatable.
//
// Author: Mike Kestner <mkestner@speakeasy.net>
//
// (c) 2002-2003 Mike Kestner

namespace GtkSharp.Generation {

	using System;
	using System.IO;
	using System.Xml;

	public class CallbackGen : GenBase, IGeneratable  {

		private Parameters parms;

		public CallbackGen (XmlElement ns, XmlElement elem) : base (ns, elem) 
		{
			if (elem ["parameters"] != null)
				parms = new Parameters (elem ["parameters"], NS);
		}

		public string MarshalType {
			get
			{
				return NS + "Sharp." + Name + "Native";
			}
		}

		public string MarshalReturnType {
			get
			{
				return MarshalType;
			}
		}

		public string CallByName (string var_name)
		{
			return var_name + ".NativeDelegate";
		}

		public string FromNative(string var)
		{
			return var;
		}

		public string FromNativeReturn(string var)
		{
			return FromNative (var);
		}

		public virtual string ToNativeReturn(string var)
		{
			return CallByName (var);
		}
		
		public string GenWrapper (string ns, GenerationInfo gen_info)
		{
			string wrapper = Name + "Native";
			string qualname = ns + "Sharp." + wrapper;

			StreamWriter sw = gen_info.OpenStream (qualname);

			sw.WriteLine ("namespace " + ns + "Sharp {");
			sw.WriteLine ();
			sw.WriteLine ("\tusing System;");
			sw.WriteLine ();

			sw.WriteLine ("#region Autogenerated code");
			string import_sig = "";
			string sig = "";
			if (parms != null)
			{
				parms.HideData = true;
				parms.CreateSignature (false);
				import_sig = parms.ImportSig;
				sig = parms.Signature;
			}

			SymbolTable table = SymbolTable.Table;

			XmlElement ret_elem = Elem["return-type"];
			string rettype = ret_elem.GetAttribute("type");
			string m_ret = table.GetMarshalReturnType (rettype);
			string s_ret = table.GetCSType (rettype);
			ClassBase ret_wrapper = table.GetClassGen (rettype);

			sw.WriteLine ("\tinternal delegate " + m_ret + " " + wrapper + "(" + import_sig + ");");
			sw.WriteLine ();
			
			sw.WriteLine ("\tinternal class " + Name + "Wrapper : GLib.DelegateWrapper {");
			if (m_ret != "void") {
				if (table.IsEnum (rettype)) {
					sw.WriteLine ("\t\tstatic int _dummy;");
				} else if (ret_wrapper != null && (ret_wrapper is ObjectGen || ret_wrapper is OpaqueGen)) {
					// Do nothing
				} else if (!table.IsStruct (rettype) && !table.IsBoxed (rettype)) {
					sw.WriteLine ("\t\tstatic {0} _dummy;", m_ret);
				}
			}
			
			sw.WriteLine ();
			sw.WriteLine ("\t\tpublic " + m_ret + " NativeCallback (" + import_sig + ")");
			sw.WriteLine ("\t\t{");

			int count = (parms != null) ? parms.Count : 0;
			if (count > 0)
				sw.WriteLine ("\t\t\tobject[] _args = new object[{0}];", count);
			int idx = 0;
			bool need_sep = false;
			bool need_ref_owned = true;
			string call_str = "";
			for (int i = 0; i < count; i++)
			{
				string parm_name = parms[i].Name;
				string ctype = parms[i].CType;

				if (i > 0 && parms[i].IsLength && parms[i-1].IsString)
					continue;

				if ((i == count - 1) && ctype == "gpointer" && (parm_name.EndsWith ("data") || parm_name.EndsWith ("data_or_owner"))) 
					continue;

				string cstype = parms[i].CSType;
				// FIXME: Too much code copy/pasted here. Refactor?
				ClassBase parm_wrapper = table.GetClassGen (ctype);
				if (need_ref_owned && parm_wrapper != null && ((parm_wrapper is ObjectGen) || (parm_wrapper is InterfaceGen))) {
					need_ref_owned = false;
					sw.WriteLine("\t\t\tbool ref_owned = false;");
				}
				sw.WriteLine("\t\t\t_args[" + idx + "] = " + table.FromNative (ctype, parm_name) + ";");
				if ((parm_wrapper != null && ((parm_wrapper is OpaqueGen))) || table.IsManuallyWrapped (ctype)) {
					sw.WriteLine("\t\t\tif (_args[" + idx + "] == null)");
					sw.WriteLine("\t\t\t\t_args[{0}] = new {1}({2});", idx, cstype, parm_name);
				}
				if (need_sep)
					call_str += ", ";
				else
					need_sep = true;
				call_str += String.Format ("({0}) _args[{1}]", cstype, idx);
				idx++;
			}

			sw.Write ("\t\t\t");
			string invoke = "_managed (" + call_str + ")";
			if (m_ret != "void") {
					if (ret_wrapper != null && (ret_wrapper is ObjectGen || ret_wrapper is OpaqueGen))
						sw.WriteLine ("return (({0}) {1}).Handle;", s_ret, invoke);
					else if (table.IsStruct (rettype) || table.IsBoxed (rettype)) {
						// Shoot. I have no idea what to do here.
						sw.WriteLine ("return IntPtr.Zero;"); 
					}
					else if (table.IsEnum (rettype))
						sw.WriteLine ("return (int) {0};", invoke);
					else
						sw.WriteLine ("return ({0}) {1};", m_ret, table.ToNativeReturn (rettype, invoke));
			}
			else
				sw.WriteLine (invoke + ";");
			sw.WriteLine ("\t\t}");
			sw.WriteLine ();

			sw.WriteLine ("\t\tinternal {0} NativeDelegate;", wrapper);
			sw.WriteLine ("\t\tprotected {0} _managed;", NS + "." + Name);
			sw.WriteLine ();

			sw.WriteLine ("\t\tpublic {0} ({1} managed, object o) : base (o)", Name + "Wrapper", NS + "." + Name);
			sw.WriteLine ("\t\t{");

			sw.WriteLine ("\t\t\tNativeDelegate = new {0} (NativeCallback);", wrapper);
			sw.WriteLine ("\t\t\t_managed = managed;");
			sw.WriteLine ("\t\t}");

			sw.WriteLine ("\t}");

			sw.WriteLine ("#endregion");
			CloseWriter (sw);
			return ns + "Sharp." + Name + "Wrapper";
		}
		
		public void Generate ()
		{
			GenerationInfo gen_info = new GenerationInfo (NSElem);
			Generate (gen_info);
		}

		public void Generate (GenerationInfo gen_info)
		{
			XmlElement ret_elem = Elem["return-type"];
			if (ret_elem == null) {
				Console.WriteLine("No return type in callback " + CName);
				Statistics.ThrottledCount++;
				return;
			}

			SymbolTable table = SymbolTable.Table;

			string rettype = ret_elem.GetAttribute("type");
			string s_ret = table.GetCSType (rettype);
			if (s_ret == "") {
				Console.WriteLine("rettype: " + rettype + " in callback " + CName);
				Statistics.ThrottledCount++;
				return;
			}

			if ((parms != null) && !parms.Validate ()) {
				Console.WriteLine(" in callback " + CName + " **** Stubbing it out ****");
				Statistics.ThrottledCount++;
				parms = null;
			}

			StreamWriter sw = gen_info.OpenStream (Name);

			string sig = "";
			if (parms != null) {
				parms.HideData = true;
				parms.CreateSignature (false);
				sig = parms.Signature;
			}

			sw.WriteLine ("namespace " + NS + " {");
			sw.WriteLine ();
			sw.WriteLine ("\tusing System;");
			sw.WriteLine ();
			sw.WriteLine ("\tpublic delegate " + s_ret + " " + Name + "(" + sig + ");");
			sw.WriteLine ();
			sw.WriteLine ("}");

			sw.Close ();
			
			GenWrapper (NS, gen_info);

			Statistics.CBCount++;
		}
	}
}

