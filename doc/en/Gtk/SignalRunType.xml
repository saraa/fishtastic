<Type Name="SignalRunType" FullName="Gtk.SignalRunType">
  <TypeSignature Language="C#" Value="public enum SignalRunType" Maintainer="auto" />
  <AssemblyInfo>
    <AssemblyName>gtk-sharp</AssemblyName>
    <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 71 EB 6C 55 75 52 9C BF 72 44 F7 A6 EA 05 62 84 F9 EA E0 3B CF F2 CC 13 2C 9C 49 0A B3 09 EA B0 B5 6B CE 44 9D F5 03 D9 C0 A8 1E 52 05 85 CD BE 70 E2 FB 90 43 4B AC 04 FA 62 22 A8 00 98 B7 A1 A7 B3 AF 99 1A 41 23 24 BB 43 25 F6 B8 65 BB 64 EB F6 D1 C2 06 D5 73 2D DF BC 70 A7 38 9E E5 3E 0C 24 6E 32 79 74 1A D0 05 03 E4 98 42 E1 9B F3 7B 19 8B 40 21 26 CB 36 89 C2 EA 64 96 A4 7C B4]</AssemblyPublicKey>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyCulture>neutral</AssemblyCulture>
    <Attributes />
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the <link location="node:gtk-sharp/programming/threads">Gtk# Thread Programming</link> for details.</ThreadSafetyStatement>
  <Docs>
    <summary>Gtk.SignalRunType is deprecated and should not be used in newly-written code.</summary>
    <remarks>These configure the signal's emission. They control whether the signal can be emitted recursively on an object and whether to run the default method before or after the user-defined handlers.</remarks>
  </Docs>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes />
  <Members>
    <Member MemberName="GtkRunFirst">
      <MemberSignature Language="C#" Value="GtkRunFirst" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.SignalRunType</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>Run the default handler before the connected user-defined handlers.</summary>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="GtkRunLast">
      <MemberSignature Language="C#" Value="GtkRunLast" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.SignalRunType</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>Run the default handler after the connected user-defined handlers. (Handlers registered as "after" always run after the default handler though)</summary>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="GtkRunBoth">
      <MemberSignature Language="C#" Value="GtkRunBoth" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.SignalRunType</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>Run the default handler twice, once before the user-defined handlers, and once after.</summary>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="GtkRunNoRecurse">
      <MemberSignature Language="C#" Value="GtkRunNoRecurse" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.SignalRunType</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>Whether to prevent a handler or hook from reemitting the signal from within itself. Attempts to emit the signal while it is running will result in the signal emission being restarted once it is done with the current processing.</summary>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="GtkRunAction">
      <MemberSignature Language="C#" Value="GtkRunAction" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.SignalRunType</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>The signal is an action you can invoke without any particular setup or cleanup. The signal is treated no differently, but some other code can determine if the signal is appropriate to delegate to user control. For example, key binding sets only allow bindings of ACTION signals to keystrokes.</summary>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="GtkRunNoHooks">
      <MemberSignature Language="C#" Value="GtkRunNoHooks" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.SignalRunType</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>This prevents the connection of emission hooks to the signal.</summary>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="value__">
      <MemberSignature Language="C#" Value="value__" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>Internal field.</summary>
        <remarks>Do not use.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
